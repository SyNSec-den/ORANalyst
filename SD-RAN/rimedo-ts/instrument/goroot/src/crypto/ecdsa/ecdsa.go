// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:5
// Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:5
// defined in FIPS 186-4 and SEC 1, Version 2.0.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:5
//
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:5
// Signatures generated by this package are not deterministic, but entropy is
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:5
// mixed with the private key and the message, achieving the same level of
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:5
// security in case of randomness source failure.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:11
package ecdsa

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:11
import (
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:11
	_go_fuzz_dep_ "go-fuzz-dep"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:11
)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:11
import (
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:11
	_atomic_ "sync/atomic"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:11
)

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:22
import (
	"bytes"
	"crypto"
	"crypto/aes"
	"crypto/cipher"
	"crypto/ecdh"
	"crypto/elliptic"
	"crypto/internal/bigmod"
	"crypto/internal/boring"
	"crypto/internal/boring/bbig"
	"crypto/internal/nistec"
	"crypto/internal/randutil"
	"crypto/sha512"
	"crypto/subtle"
	"errors"
	"io"
	"math/big"
	"sync"

	"golang.org/x/crypto/cryptobyte"
	"golang.org/x/crypto/cryptobyte/asn1"
)

// PublicKey represents an ECDSA public key.
type PublicKey struct {
	elliptic.Curve
	X, Y	*big.Int
}

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:54
// ECDH returns k as a [ecdh.PublicKey]. It returns an error if the key is
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:54
// invalid according to the definition of [ecdh.Curve.NewPublicKey], or if the
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:54
// Curve is not supported by crypto/ecdh.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:57
func (k *PublicKey) ECDH() (*ecdh.PublicKey, error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:57
	_go_fuzz_dep_.CoverTab[8838]++
							c := curveToECDH(k.Curve)
							if c == nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:59
		_go_fuzz_dep_.CoverTab[8841]++
								return nil, errors.New("ecdsa: unsupported curve by crypto/ecdh")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:60
		// _ = "end of CoverTab[8841]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:61
		_go_fuzz_dep_.CoverTab[8842]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:61
		// _ = "end of CoverTab[8842]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:61
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:61
	// _ = "end of CoverTab[8838]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:61
	_go_fuzz_dep_.CoverTab[8839]++
							if !k.Curve.IsOnCurve(k.X, k.Y) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:62
		_go_fuzz_dep_.CoverTab[8843]++
								return nil, errors.New("ecdsa: invalid public key")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:63
		// _ = "end of CoverTab[8843]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:64
		_go_fuzz_dep_.CoverTab[8844]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:64
		// _ = "end of CoverTab[8844]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:64
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:64
	// _ = "end of CoverTab[8839]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:64
	_go_fuzz_dep_.CoverTab[8840]++
							return c.NewPublicKey(elliptic.Marshal(k.Curve, k.X, k.Y))
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:65
	// _ = "end of CoverTab[8840]"
}

// Equal reports whether pub and x have the same value.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:68
//
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:68
// Two keys are only considered to have the same value if they have the same Curve value.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:68
// Note that for example elliptic.P256() and elliptic.P256().Params() are different
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:68
// values, as the latter is a generic not constant time implementation.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:73
func (pub *PublicKey) Equal(x crypto.PublicKey) bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:73
	_go_fuzz_dep_.CoverTab[8845]++
							xx, ok := x.(*PublicKey)
							if !ok {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:75
		_go_fuzz_dep_.CoverTab[8847]++
								return false
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:76
		// _ = "end of CoverTab[8847]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:77
		_go_fuzz_dep_.CoverTab[8848]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:77
		// _ = "end of CoverTab[8848]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:77
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:77
	// _ = "end of CoverTab[8845]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:77
	_go_fuzz_dep_.CoverTab[8846]++
							return bigIntEqual(pub.X, xx.X) && func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:78
		_go_fuzz_dep_.CoverTab[8849]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:78
		return bigIntEqual(pub.Y, xx.Y)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:78
		// _ = "end of CoverTab[8849]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:78
	}() && func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:78
		_go_fuzz_dep_.CoverTab[8850]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:78
		return pub.Curve == xx.Curve
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:83
		// _ = "end of CoverTab[8850]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:83
	}()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:83
	// _ = "end of CoverTab[8846]"
}

// PrivateKey represents an ECDSA private key.
type PrivateKey struct {
	PublicKey
	D	*big.Int
}

// ECDH returns k as a [ecdh.PrivateKey]. It returns an error if the key is
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:92
// invalid according to the definition of [ecdh.Curve.NewPrivateKey], or if the
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:92
// Curve is not supported by crypto/ecdh.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:95
func (k *PrivateKey) ECDH() (*ecdh.PrivateKey, error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:95
	_go_fuzz_dep_.CoverTab[8851]++
							c := curveToECDH(k.Curve)
							if c == nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:97
		_go_fuzz_dep_.CoverTab[8854]++
								return nil, errors.New("ecdsa: unsupported curve by crypto/ecdh")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:98
		// _ = "end of CoverTab[8854]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:99
		_go_fuzz_dep_.CoverTab[8855]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:99
		// _ = "end of CoverTab[8855]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:99
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:99
	// _ = "end of CoverTab[8851]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:99
	_go_fuzz_dep_.CoverTab[8852]++
							size := (k.Curve.Params().N.BitLen() + 7) / 8
							if k.D.BitLen() > size*8 {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:101
		_go_fuzz_dep_.CoverTab[8856]++
								return nil, errors.New("ecdsa: invalid private key")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:102
		// _ = "end of CoverTab[8856]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:103
		_go_fuzz_dep_.CoverTab[8857]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:103
		// _ = "end of CoverTab[8857]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:103
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:103
	// _ = "end of CoverTab[8852]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:103
	_go_fuzz_dep_.CoverTab[8853]++
							return c.NewPrivateKey(k.D.FillBytes(make([]byte, size)))
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:104
	// _ = "end of CoverTab[8853]"
}

func curveToECDH(c elliptic.Curve) ecdh.Curve {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:107
	_go_fuzz_dep_.CoverTab[8858]++
							switch c {
	case elliptic.P256():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:109
		_go_fuzz_dep_.CoverTab[8859]++
								return ecdh.P256()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:110
		// _ = "end of CoverTab[8859]"
	case elliptic.P384():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:111
		_go_fuzz_dep_.CoverTab[8860]++
								return ecdh.P384()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:112
		// _ = "end of CoverTab[8860]"
	case elliptic.P521():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:113
		_go_fuzz_dep_.CoverTab[8861]++
								return ecdh.P521()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:114
		// _ = "end of CoverTab[8861]"
	default:
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:115
		_go_fuzz_dep_.CoverTab[8862]++
								return nil
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:116
		// _ = "end of CoverTab[8862]"
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:117
	// _ = "end of CoverTab[8858]"
}

// Public returns the public key corresponding to priv.
func (priv *PrivateKey) Public() crypto.PublicKey {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:121
	_go_fuzz_dep_.CoverTab[8863]++
							return &priv.PublicKey
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:122
	// _ = "end of CoverTab[8863]"
}

// Equal reports whether priv and x have the same value.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:125
//
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:125
// See PublicKey.Equal for details on how Curve is compared.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:128
func (priv *PrivateKey) Equal(x crypto.PrivateKey) bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:128
	_go_fuzz_dep_.CoverTab[8864]++
							xx, ok := x.(*PrivateKey)
							if !ok {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:130
		_go_fuzz_dep_.CoverTab[8866]++
								return false
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:131
		// _ = "end of CoverTab[8866]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:132
		_go_fuzz_dep_.CoverTab[8867]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:132
		// _ = "end of CoverTab[8867]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:132
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:132
	// _ = "end of CoverTab[8864]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:132
	_go_fuzz_dep_.CoverTab[8865]++
							return priv.PublicKey.Equal(&xx.PublicKey) && func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:133
		_go_fuzz_dep_.CoverTab[8868]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:133
		return bigIntEqual(priv.D, xx.D)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:133
		// _ = "end of CoverTab[8868]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:133
	}()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:133
	// _ = "end of CoverTab[8865]"
}

// bigIntEqual reports whether a and b are equal leaking only their bit length
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:136
// through timing side-channels.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:138
func bigIntEqual(a, b *big.Int) bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:138
	_go_fuzz_dep_.CoverTab[8869]++
							return subtle.ConstantTimeCompare(a.Bytes(), b.Bytes()) == 1
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:139
	// _ = "end of CoverTab[8869]"
}

// Sign signs digest with priv, reading randomness from rand. The opts argument
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:142
// is not currently used but, in keeping with the crypto.Signer interface,
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:142
// should be the hash function used to digest the message.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:142
//
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:142
// This method implements crypto.Signer, which is an interface to support keys
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:142
// where the private part is kept in, for example, a hardware module. Common
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:142
// uses can use the SignASN1 function in this package directly.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:149
func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:149
	_go_fuzz_dep_.CoverTab[8870]++
							return SignASN1(rand, priv, digest)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:150
	// _ = "end of CoverTab[8870]"
}

// GenerateKey generates a public and private key pair.
func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:154
	_go_fuzz_dep_.CoverTab[8871]++
							randutil.MaybeReadByte(rand)

							if boring.Enabled && func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:157
		_go_fuzz_dep_.CoverTab[8873]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:157
		return rand == boring.RandReader
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:157
		// _ = "end of CoverTab[8873]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:157
	}() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:157
		_go_fuzz_dep_.CoverTab[8874]++
								x, y, d, err := boring.GenerateKeyECDSA(c.Params().Name)
								if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:159
			_go_fuzz_dep_.CoverTab[8876]++
									return nil, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:160
			// _ = "end of CoverTab[8876]"
		} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:161
			_go_fuzz_dep_.CoverTab[8877]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:161
			// _ = "end of CoverTab[8877]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:161
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:161
		// _ = "end of CoverTab[8874]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:161
		_go_fuzz_dep_.CoverTab[8875]++
								return &PrivateKey{PublicKey: PublicKey{Curve: c, X: bbig.Dec(x), Y: bbig.Dec(y)}, D: bbig.Dec(d)}, nil
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:162
		// _ = "end of CoverTab[8875]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:163
		_go_fuzz_dep_.CoverTab[8878]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:163
		// _ = "end of CoverTab[8878]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:163
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:163
	// _ = "end of CoverTab[8871]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:163
	_go_fuzz_dep_.CoverTab[8872]++
							boring.UnreachableExceptTests()

							switch c.Params() {
	case elliptic.P224().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:167
		_go_fuzz_dep_.CoverTab[8879]++
								return generateNISTEC(p224(), rand)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:168
		// _ = "end of CoverTab[8879]"
	case elliptic.P256().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:169
		_go_fuzz_dep_.CoverTab[8880]++
								return generateNISTEC(p256(), rand)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:170
		// _ = "end of CoverTab[8880]"
	case elliptic.P384().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:171
		_go_fuzz_dep_.CoverTab[8881]++
								return generateNISTEC(p384(), rand)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:172
		// _ = "end of CoverTab[8881]"
	case elliptic.P521().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:173
		_go_fuzz_dep_.CoverTab[8882]++
								return generateNISTEC(p521(), rand)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:174
		// _ = "end of CoverTab[8882]"
	default:
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:175
		_go_fuzz_dep_.CoverTab[8883]++
								return generateLegacy(c, rand)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:176
		// _ = "end of CoverTab[8883]"
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:177
	// _ = "end of CoverTab[8872]"
}

func generateNISTEC[Point nistPoint[Point]](c *nistCurve[Point], rand io.Reader) (*PrivateKey, error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:180
	_go_fuzz_dep_.CoverTab[8884]++
							k, Q, err := randomPoint(c, rand)
							if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:182
		_go_fuzz_dep_.CoverTab[8887]++
								return nil, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:183
		// _ = "end of CoverTab[8887]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:184
		_go_fuzz_dep_.CoverTab[8888]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:184
		// _ = "end of CoverTab[8888]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:184
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:184
	// _ = "end of CoverTab[8884]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:184
	_go_fuzz_dep_.CoverTab[8885]++

							priv := new(PrivateKey)
							priv.PublicKey.Curve = c.curve
							priv.D = new(big.Int).SetBytes(k.Bytes(c.N))
							priv.PublicKey.X, priv.PublicKey.Y, err = c.pointToAffine(Q)
							if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:190
		_go_fuzz_dep_.CoverTab[8889]++
								return nil, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:191
		// _ = "end of CoverTab[8889]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:192
		_go_fuzz_dep_.CoverTab[8890]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:192
		// _ = "end of CoverTab[8890]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:192
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:192
	// _ = "end of CoverTab[8885]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:192
	_go_fuzz_dep_.CoverTab[8886]++
							return priv, nil
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:193
	// _ = "end of CoverTab[8886]"
}

// randomPoint returns a random scalar and the corresponding point using the
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:196
// procedure given in FIPS 186-4, Appendix B.5.2 (rejection sampling).
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:198
func randomPoint[Point nistPoint[Point]](c *nistCurve[Point], rand io.Reader) (k *bigmod.Nat, p Point, err error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:198
	_go_fuzz_dep_.CoverTab[8891]++
							k = bigmod.NewNat()
							for {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:200
		_go_fuzz_dep_.CoverTab[8893]++
								b := make([]byte, c.N.Size())
								if _, err = io.ReadFull(rand, b); err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:202
			_go_fuzz_dep_.CoverTab[8897]++
									return
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:203
			// _ = "end of CoverTab[8897]"
		} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:204
			_go_fuzz_dep_.CoverTab[8898]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:204
			// _ = "end of CoverTab[8898]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:204
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:204
		// _ = "end of CoverTab[8893]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:204
		_go_fuzz_dep_.CoverTab[8894]++

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:210
		if excess := len(b)*8 - c.N.BitLen(); excess > 0 {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:210
			_go_fuzz_dep_.CoverTab[8899]++

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:213
			if excess != 0 && func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:213
				_go_fuzz_dep_.CoverTab[8901]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:213
				return c.curve.Params().Name != "P-521"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:213
				// _ = "end of CoverTab[8901]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:213
			}() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:213
				_go_fuzz_dep_.CoverTab[8902]++
										panic("ecdsa: internal error: unexpectedly masking off bits")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:214
				// _ = "end of CoverTab[8902]"
			} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:215
				_go_fuzz_dep_.CoverTab[8903]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:215
				// _ = "end of CoverTab[8903]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:215
			}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:215
			// _ = "end of CoverTab[8899]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:215
			_go_fuzz_dep_.CoverTab[8900]++
									b[0] >>= excess
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:216
			// _ = "end of CoverTab[8900]"
		} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:217
			_go_fuzz_dep_.CoverTab[8904]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:217
			// _ = "end of CoverTab[8904]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:217
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:217
		// _ = "end of CoverTab[8894]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:217
		_go_fuzz_dep_.CoverTab[8895]++

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:223
		if _, err = k.SetBytes(b, c.N); err == nil && func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:223
			_go_fuzz_dep_.CoverTab[8905]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:223
			return k.IsZero() == 0
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:223
			// _ = "end of CoverTab[8905]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:223
		}() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:223
			_go_fuzz_dep_.CoverTab[8906]++
									break
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:224
			// _ = "end of CoverTab[8906]"
		} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:225
			_go_fuzz_dep_.CoverTab[8907]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:225
			// _ = "end of CoverTab[8907]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:225
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:225
		// _ = "end of CoverTab[8895]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:225
		_go_fuzz_dep_.CoverTab[8896]++

								if testingOnlyRejectionSamplingLooped != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:227
			_go_fuzz_dep_.CoverTab[8908]++
									testingOnlyRejectionSamplingLooped()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:228
			// _ = "end of CoverTab[8908]"
		} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:229
			_go_fuzz_dep_.CoverTab[8909]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:229
			// _ = "end of CoverTab[8909]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:229
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:229
		// _ = "end of CoverTab[8896]"
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:230
	// _ = "end of CoverTab[8891]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:230
	_go_fuzz_dep_.CoverTab[8892]++

							p, err = c.newPoint().ScalarBaseMult(k.Bytes(c.N))
							return
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:233
	// _ = "end of CoverTab[8892]"
}

// testingOnlyRejectionSamplingLooped is called when rejection sampling in
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:236
// randomPoint rejects a candidate for being higher than the modulus.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:238
var testingOnlyRejectionSamplingLooped func()

// errNoAsm is returned by signAsm and verifyAsm when the assembly
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:240
// implementation is not available.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:242
var errNoAsm = errors.New("no assembly implementation available")

// SignASN1 signs a hash (which should be the result of hashing a larger message)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:244
// using the private key, priv. If the hash is longer than the bit-length of the
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:244
// private key's curve order, the hash will be truncated to that length. It
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:244
// returns the ASN.1 encoded signature.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:248
func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:248
	_go_fuzz_dep_.CoverTab[8910]++
							randutil.MaybeReadByte(rand)

							if boring.Enabled && func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:251
		_go_fuzz_dep_.CoverTab[8914]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:251
		return rand == boring.RandReader
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:251
		// _ = "end of CoverTab[8914]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:251
	}() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:251
		_go_fuzz_dep_.CoverTab[8915]++
								b, err := boringPrivateKey(priv)
								if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:253
			_go_fuzz_dep_.CoverTab[8917]++
									return nil, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:254
			// _ = "end of CoverTab[8917]"
		} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:255
			_go_fuzz_dep_.CoverTab[8918]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:255
			// _ = "end of CoverTab[8918]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:255
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:255
		// _ = "end of CoverTab[8915]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:255
		_go_fuzz_dep_.CoverTab[8916]++
								return boring.SignMarshalECDSA(b, hash)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:256
		// _ = "end of CoverTab[8916]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:257
		_go_fuzz_dep_.CoverTab[8919]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:257
		// _ = "end of CoverTab[8919]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:257
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:257
	// _ = "end of CoverTab[8910]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:257
	_go_fuzz_dep_.CoverTab[8911]++
							boring.UnreachableExceptTests()

							csprng, err := mixedCSPRNG(rand, priv, hash)
							if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:261
		_go_fuzz_dep_.CoverTab[8920]++
								return nil, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:262
		// _ = "end of CoverTab[8920]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:263
		_go_fuzz_dep_.CoverTab[8921]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:263
		// _ = "end of CoverTab[8921]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:263
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:263
	// _ = "end of CoverTab[8911]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:263
	_go_fuzz_dep_.CoverTab[8912]++

							if sig, err := signAsm(priv, csprng, hash); err != errNoAsm {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:265
		_go_fuzz_dep_.CoverTab[8922]++
								return sig, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:266
		// _ = "end of CoverTab[8922]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:267
		_go_fuzz_dep_.CoverTab[8923]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:267
		// _ = "end of CoverTab[8923]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:267
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:267
	// _ = "end of CoverTab[8912]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:267
	_go_fuzz_dep_.CoverTab[8913]++

							switch priv.Curve.Params() {
	case elliptic.P224().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:270
		_go_fuzz_dep_.CoverTab[8924]++
								return signNISTEC(p224(), priv, csprng, hash)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:271
		// _ = "end of CoverTab[8924]"
	case elliptic.P256().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:272
		_go_fuzz_dep_.CoverTab[8925]++
								return signNISTEC(p256(), priv, csprng, hash)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:273
		// _ = "end of CoverTab[8925]"
	case elliptic.P384().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:274
		_go_fuzz_dep_.CoverTab[8926]++
								return signNISTEC(p384(), priv, csprng, hash)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:275
		// _ = "end of CoverTab[8926]"
	case elliptic.P521().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:276
		_go_fuzz_dep_.CoverTab[8927]++
								return signNISTEC(p521(), priv, csprng, hash)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:277
		// _ = "end of CoverTab[8927]"
	default:
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:278
		_go_fuzz_dep_.CoverTab[8928]++
								return signLegacy(priv, csprng, hash)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:279
		// _ = "end of CoverTab[8928]"
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:280
	// _ = "end of CoverTab[8913]"
}

func signNISTEC[Point nistPoint[Point]](c *nistCurve[Point], priv *PrivateKey, csprng io.Reader, hash []byte) (sig []byte, err error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:283
	_go_fuzz_dep_.CoverTab[8929]++

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:286
	k, R, err := randomPoint(c, csprng)
	if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:287
		_go_fuzz_dep_.CoverTab[8936]++
								return nil, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:288
		// _ = "end of CoverTab[8936]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:289
		_go_fuzz_dep_.CoverTab[8937]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:289
		// _ = "end of CoverTab[8937]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:289
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:289
	// _ = "end of CoverTab[8929]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:289
	_go_fuzz_dep_.CoverTab[8930]++

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:292
	kInv := bigmod.NewNat()
	inverse(c, kInv, k)

	Rx, err := R.BytesX()
	if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:296
		_go_fuzz_dep_.CoverTab[8938]++
								return nil, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:297
		// _ = "end of CoverTab[8938]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:298
		_go_fuzz_dep_.CoverTab[8939]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:298
		// _ = "end of CoverTab[8939]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:298
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:298
	// _ = "end of CoverTab[8930]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:298
	_go_fuzz_dep_.CoverTab[8931]++
							r, err := bigmod.NewNat().SetOverflowingBytes(Rx, c.N)
							if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:300
		_go_fuzz_dep_.CoverTab[8940]++
								return nil, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:301
		// _ = "end of CoverTab[8940]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:302
		_go_fuzz_dep_.CoverTab[8941]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:302
		// _ = "end of CoverTab[8941]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:302
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:302
	// _ = "end of CoverTab[8931]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:302
	_go_fuzz_dep_.CoverTab[8932]++

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:307
	if r.IsZero() == 1 {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:307
		_go_fuzz_dep_.CoverTab[8942]++
								return nil, errors.New("ecdsa: internal error: r is zero")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:308
		// _ = "end of CoverTab[8942]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:309
		_go_fuzz_dep_.CoverTab[8943]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:309
		// _ = "end of CoverTab[8943]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:309
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:309
	// _ = "end of CoverTab[8932]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:309
	_go_fuzz_dep_.CoverTab[8933]++

							e := bigmod.NewNat()
							hashToNat(c, e, hash)

							s, err := bigmod.NewNat().SetBytes(priv.D.Bytes(), c.N)
							if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:315
		_go_fuzz_dep_.CoverTab[8944]++
								return nil, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:316
		// _ = "end of CoverTab[8944]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:317
		_go_fuzz_dep_.CoverTab[8945]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:317
		// _ = "end of CoverTab[8945]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:317
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:317
	// _ = "end of CoverTab[8933]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:317
	_go_fuzz_dep_.CoverTab[8934]++
							s.Mul(r, c.N)
							s.Add(e, c.N)
							s.Mul(kInv, c.N)

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:323
	if s.IsZero() == 1 {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:323
		_go_fuzz_dep_.CoverTab[8946]++
								return nil, errors.New("ecdsa: internal error: s is zero")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:324
		// _ = "end of CoverTab[8946]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:325
		_go_fuzz_dep_.CoverTab[8947]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:325
		// _ = "end of CoverTab[8947]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:325
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:325
	// _ = "end of CoverTab[8934]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:325
	_go_fuzz_dep_.CoverTab[8935]++

							return encodeSignature(r.Bytes(c.N), s.Bytes(c.N))
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:327
	// _ = "end of CoverTab[8935]"
}

func encodeSignature(r, s []byte) ([]byte, error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:330
	_go_fuzz_dep_.CoverTab[8948]++
							var b cryptobyte.Builder
							b.AddASN1(asn1.SEQUENCE, func(b *cryptobyte.Builder) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:332
		_go_fuzz_dep_.CoverTab[8950]++
								addASN1IntBytes(b, r)
								addASN1IntBytes(b, s)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:334
		// _ = "end of CoverTab[8950]"
	})
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:335
	// _ = "end of CoverTab[8948]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:335
	_go_fuzz_dep_.CoverTab[8949]++
							return b.Bytes()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:336
	// _ = "end of CoverTab[8949]"
}

// addASN1IntBytes encodes in ASN.1 a positive integer represented as
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:339
// a big-endian byte slice with zero or more leading zeroes.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:341
func addASN1IntBytes(b *cryptobyte.Builder, bytes []byte) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:341
	_go_fuzz_dep_.CoverTab[8951]++
							for len(bytes) > 0 && func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:342
		_go_fuzz_dep_.CoverTab[8954]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:342
		return bytes[0] == 0
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:342
		// _ = "end of CoverTab[8954]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:342
	}() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:342
		_go_fuzz_dep_.CoverTab[8955]++
								bytes = bytes[1:]
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:343
		// _ = "end of CoverTab[8955]"
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:344
	// _ = "end of CoverTab[8951]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:344
	_go_fuzz_dep_.CoverTab[8952]++
							if len(bytes) == 0 {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:345
		_go_fuzz_dep_.CoverTab[8956]++
								b.SetError(errors.New("invalid integer"))
								return
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:347
		// _ = "end of CoverTab[8956]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:348
		_go_fuzz_dep_.CoverTab[8957]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:348
		// _ = "end of CoverTab[8957]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:348
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:348
	// _ = "end of CoverTab[8952]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:348
	_go_fuzz_dep_.CoverTab[8953]++
							b.AddASN1(asn1.INTEGER, func(c *cryptobyte.Builder) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:349
		_go_fuzz_dep_.CoverTab[8958]++
								if bytes[0]&0x80 != 0 {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:350
			_go_fuzz_dep_.CoverTab[8960]++
									c.AddUint8(0)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:351
			// _ = "end of CoverTab[8960]"
		} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:352
			_go_fuzz_dep_.CoverTab[8961]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:352
			// _ = "end of CoverTab[8961]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:352
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:352
		// _ = "end of CoverTab[8958]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:352
		_go_fuzz_dep_.CoverTab[8959]++
								c.AddBytes(bytes)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:353
		// _ = "end of CoverTab[8959]"
	})
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:354
	// _ = "end of CoverTab[8953]"
}

// inverse sets kInv to the inverse of k modulo the order of the curve.
func inverse[Point nistPoint[Point]](c *nistCurve[Point], kInv, k *bigmod.Nat) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:358
	_go_fuzz_dep_.CoverTab[8962]++
							if c.curve.Params().Name == "P-256" {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:359
		_go_fuzz_dep_.CoverTab[8964]++
								kBytes, err := nistec.P256OrdInverse(k.Bytes(c.N))

								if err == nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:362
			_go_fuzz_dep_.CoverTab[8965]++
									_, err := kInv.SetBytes(kBytes, c.N)
									if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:364
				_go_fuzz_dep_.CoverTab[8967]++
										panic("ecdsa: internal error: P256OrdInverse produced an invalid value")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:365
				// _ = "end of CoverTab[8967]"
			} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:366
				_go_fuzz_dep_.CoverTab[8968]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:366
				// _ = "end of CoverTab[8968]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:366
			}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:366
			// _ = "end of CoverTab[8965]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:366
			_go_fuzz_dep_.CoverTab[8966]++
									return
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:367
			// _ = "end of CoverTab[8966]"
		} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:368
			_go_fuzz_dep_.CoverTab[8969]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:368
			// _ = "end of CoverTab[8969]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:368
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:368
		// _ = "end of CoverTab[8964]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:369
		_go_fuzz_dep_.CoverTab[8970]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:369
		// _ = "end of CoverTab[8970]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:369
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:369
	// _ = "end of CoverTab[8962]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:369
	_go_fuzz_dep_.CoverTab[8963]++

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:373
	kInv.Exp(k, c.nMinus2, c.N)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:373
	// _ = "end of CoverTab[8963]"
}

// hashToNat sets e to the left-most bits of hash, according to
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:376
// SEC 1, Section 4.1.3, point 5 and Section 4.1.4, point 3.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:378
func hashToNat[Point nistPoint[Point]](c *nistCurve[Point], e *bigmod.Nat, hash []byte) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:378
	_go_fuzz_dep_.CoverTab[8971]++

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:383
	if size := c.N.Size(); len(hash) >= size {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:383
		_go_fuzz_dep_.CoverTab[8973]++
								hash = hash[:size]
								if excess := len(hash)*8 - c.N.BitLen(); excess > 0 {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:385
			_go_fuzz_dep_.CoverTab[8974]++
									hash = bytes.Clone(hash)
									for i := len(hash) - 1; i >= 0; i-- {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:387
				_go_fuzz_dep_.CoverTab[8975]++
										hash[i] >>= excess
										if i > 0 {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:389
					_go_fuzz_dep_.CoverTab[8976]++
											hash[i] |= hash[i-1] << (8 - excess)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:390
					// _ = "end of CoverTab[8976]"
				} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:391
					_go_fuzz_dep_.CoverTab[8977]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:391
					// _ = "end of CoverTab[8977]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:391
				}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:391
				// _ = "end of CoverTab[8975]"
			}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:392
			// _ = "end of CoverTab[8974]"
		} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:393
			_go_fuzz_dep_.CoverTab[8978]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:393
			// _ = "end of CoverTab[8978]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:393
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:393
		// _ = "end of CoverTab[8973]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:394
		_go_fuzz_dep_.CoverTab[8979]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:394
		// _ = "end of CoverTab[8979]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:394
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:394
	// _ = "end of CoverTab[8971]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:394
	_go_fuzz_dep_.CoverTab[8972]++
							_, err := e.SetOverflowingBytes(hash, c.N)
							if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:396
		_go_fuzz_dep_.CoverTab[8980]++
								panic("ecdsa: internal error: truncated hash is too long")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:397
		// _ = "end of CoverTab[8980]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:398
		_go_fuzz_dep_.CoverTab[8981]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:398
		// _ = "end of CoverTab[8981]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:398
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:398
	// _ = "end of CoverTab[8972]"
}

// mixedCSPRNG returns a CSPRNG that mixes entropy from rand with the message
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:401
// and the private key, to protect the key in case rand fails. This is
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:401
// equivalent in security to RFC 6979 deterministic nonce generation, but still
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:401
// produces randomized signatures.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:405
func mixedCSPRNG(rand io.Reader, priv *PrivateKey, hash []byte) (io.Reader, error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:405
	_go_fuzz_dep_.CoverTab[8982]++

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:418
	entropy := make([]byte, 32)
	if _, err := io.ReadFull(rand, entropy); err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:419
		_go_fuzz_dep_.CoverTab[8985]++
								return nil, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:420
		// _ = "end of CoverTab[8985]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:421
		_go_fuzz_dep_.CoverTab[8986]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:421
		// _ = "end of CoverTab[8986]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:421
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:421
	// _ = "end of CoverTab[8982]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:421
	_go_fuzz_dep_.CoverTab[8983]++

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:424
	md := sha512.New()
							md.Write(priv.D.Bytes())
							md.Write(entropy)
							md.Write(hash)
							key := md.Sum(nil)[:32]

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:432
	block, err := aes.NewCipher(key)
	if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:433
		_go_fuzz_dep_.CoverTab[8987]++
								return nil, err
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:434
		// _ = "end of CoverTab[8987]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:435
		_go_fuzz_dep_.CoverTab[8988]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:435
		// _ = "end of CoverTab[8988]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:435
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:435
	// _ = "end of CoverTab[8983]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:435
	_go_fuzz_dep_.CoverTab[8984]++

	// Create a CSPRNG that xors a stream of zeros with
	// the output of the AES-CTR instance.
	const aesIV = "IV for ECDSA CTR"
	return &cipher.StreamReader{
		R:	zeroReader,
		S:	cipher.NewCTR(block, []byte(aesIV)),
	}, nil
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:443
	// _ = "end of CoverTab[8984]"
}

type zr struct{}

var zeroReader = zr{}

// Read replaces the contents of dst with zeros. It is safe for concurrent use.
func (zr) Read(dst []byte) (n int, err error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:451
	_go_fuzz_dep_.CoverTab[8989]++
							for i := range dst {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:452
		_go_fuzz_dep_.CoverTab[8991]++
								dst[i] = 0
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:453
		// _ = "end of CoverTab[8991]"
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:454
	// _ = "end of CoverTab[8989]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:454
	_go_fuzz_dep_.CoverTab[8990]++
							return len(dst), nil
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:455
	// _ = "end of CoverTab[8990]"
}

// VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:458
// public key, pub. Its return value records whether the signature is valid.
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:460
func VerifyASN1(pub *PublicKey, hash, sig []byte) bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:460
	_go_fuzz_dep_.CoverTab[8992]++
							if boring.Enabled {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:461
		_go_fuzz_dep_.CoverTab[8995]++
								key, err := boringPublicKey(pub)
								if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:463
			_go_fuzz_dep_.CoverTab[8997]++
									return false
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:464
			// _ = "end of CoverTab[8997]"
		} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:465
			_go_fuzz_dep_.CoverTab[8998]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:465
			// _ = "end of CoverTab[8998]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:465
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:465
		// _ = "end of CoverTab[8995]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:465
		_go_fuzz_dep_.CoverTab[8996]++
								return boring.VerifyECDSA(key, hash, sig)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:466
		// _ = "end of CoverTab[8996]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:467
		_go_fuzz_dep_.CoverTab[8999]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:467
		// _ = "end of CoverTab[8999]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:467
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:467
	// _ = "end of CoverTab[8992]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:467
	_go_fuzz_dep_.CoverTab[8993]++
							boring.UnreachableExceptTests()

							if err := verifyAsm(pub, hash, sig); err != errNoAsm {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:470
		_go_fuzz_dep_.CoverTab[9000]++
								return err == nil
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:471
		// _ = "end of CoverTab[9000]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:472
		_go_fuzz_dep_.CoverTab[9001]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:472
		// _ = "end of CoverTab[9001]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:472
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:472
	// _ = "end of CoverTab[8993]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:472
	_go_fuzz_dep_.CoverTab[8994]++

							switch pub.Curve.Params() {
	case elliptic.P224().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:475
		_go_fuzz_dep_.CoverTab[9002]++
								return verifyNISTEC(p224(), pub, hash, sig)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:476
		// _ = "end of CoverTab[9002]"
	case elliptic.P256().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:477
		_go_fuzz_dep_.CoverTab[9003]++
								return verifyNISTEC(p256(), pub, hash, sig)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:478
		// _ = "end of CoverTab[9003]"
	case elliptic.P384().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:479
		_go_fuzz_dep_.CoverTab[9004]++
								return verifyNISTEC(p384(), pub, hash, sig)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:480
		// _ = "end of CoverTab[9004]"
	case elliptic.P521().Params():
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:481
		_go_fuzz_dep_.CoverTab[9005]++
								return verifyNISTEC(p521(), pub, hash, sig)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:482
		// _ = "end of CoverTab[9005]"
	default:
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:483
		_go_fuzz_dep_.CoverTab[9006]++
								return verifyLegacy(pub, hash, sig)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:484
		// _ = "end of CoverTab[9006]"
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:485
	// _ = "end of CoverTab[8994]"
}

func verifyNISTEC[Point nistPoint[Point]](c *nistCurve[Point], pub *PublicKey, hash, sig []byte) bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:488
	_go_fuzz_dep_.CoverTab[9007]++
							rBytes, sBytes, err := parseSignature(sig)
							if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:490
		_go_fuzz_dep_.CoverTab[9016]++
								return false
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:491
		// _ = "end of CoverTab[9016]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:492
		_go_fuzz_dep_.CoverTab[9017]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:492
		// _ = "end of CoverTab[9017]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:492
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:492
	// _ = "end of CoverTab[9007]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:492
	_go_fuzz_dep_.CoverTab[9008]++

							Q, err := c.pointFromAffine(pub.X, pub.Y)
							if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:495
		_go_fuzz_dep_.CoverTab[9018]++
								return false
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:496
		// _ = "end of CoverTab[9018]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:497
		_go_fuzz_dep_.CoverTab[9019]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:497
		// _ = "end of CoverTab[9019]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:497
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:497
	// _ = "end of CoverTab[9008]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:497
	_go_fuzz_dep_.CoverTab[9009]++

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:501
	r, err := bigmod.NewNat().SetBytes(rBytes, c.N)
	if err != nil || func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:502
		_go_fuzz_dep_.CoverTab[9020]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:502
		return r.IsZero() == 1
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:502
		// _ = "end of CoverTab[9020]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:502
	}() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:502
		_go_fuzz_dep_.CoverTab[9021]++
								return false
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:503
		// _ = "end of CoverTab[9021]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:504
		_go_fuzz_dep_.CoverTab[9022]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:504
		// _ = "end of CoverTab[9022]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:504
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:504
	// _ = "end of CoverTab[9009]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:504
	_go_fuzz_dep_.CoverTab[9010]++
							s, err := bigmod.NewNat().SetBytes(sBytes, c.N)
							if err != nil || func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:506
		_go_fuzz_dep_.CoverTab[9023]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:506
		return s.IsZero() == 1
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:506
		// _ = "end of CoverTab[9023]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:506
	}() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:506
		_go_fuzz_dep_.CoverTab[9024]++
								return false
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:507
		// _ = "end of CoverTab[9024]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:508
		_go_fuzz_dep_.CoverTab[9025]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:508
		// _ = "end of CoverTab[9025]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:508
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:508
	// _ = "end of CoverTab[9010]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:508
	_go_fuzz_dep_.CoverTab[9011]++

							e := bigmod.NewNat()
							hashToNat(c, e, hash)

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:514
	w := bigmod.NewNat()
							inverse(c, w, s)

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:518
	p1, err := c.newPoint().ScalarBaseMult(e.Mul(w, c.N).Bytes(c.N))
	if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:519
		_go_fuzz_dep_.CoverTab[9026]++
								return false
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:520
		// _ = "end of CoverTab[9026]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:521
		_go_fuzz_dep_.CoverTab[9027]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:521
		// _ = "end of CoverTab[9027]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:521
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:521
	// _ = "end of CoverTab[9011]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:521
	_go_fuzz_dep_.CoverTab[9012]++

							p2, err := Q.ScalarMult(Q, w.Mul(r, c.N).Bytes(c.N))
							if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:524
		_go_fuzz_dep_.CoverTab[9028]++
								return false
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:525
		// _ = "end of CoverTab[9028]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:526
		_go_fuzz_dep_.CoverTab[9029]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:526
		// _ = "end of CoverTab[9029]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:526
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:526
	// _ = "end of CoverTab[9012]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:526
	_go_fuzz_dep_.CoverTab[9013]++

							Rx, err := p1.Add(p1, p2).BytesX()
							if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:529
		_go_fuzz_dep_.CoverTab[9030]++
								return false
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:530
		// _ = "end of CoverTab[9030]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:531
		_go_fuzz_dep_.CoverTab[9031]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:531
		// _ = "end of CoverTab[9031]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:531
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:531
	// _ = "end of CoverTab[9013]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:531
	_go_fuzz_dep_.CoverTab[9014]++

							v, err := bigmod.NewNat().SetOverflowingBytes(Rx, c.N)
							if err != nil {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:534
		_go_fuzz_dep_.CoverTab[9032]++
								return false
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:535
		// _ = "end of CoverTab[9032]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:536
		_go_fuzz_dep_.CoverTab[9033]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:536
		// _ = "end of CoverTab[9033]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:536
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:536
	// _ = "end of CoverTab[9014]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:536
	_go_fuzz_dep_.CoverTab[9015]++

							return v.Equal(r) == 1
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:538
	// _ = "end of CoverTab[9015]"
}

func parseSignature(sig []byte) (r, s []byte, err error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:541
	_go_fuzz_dep_.CoverTab[9034]++
							var inner cryptobyte.String
							input := cryptobyte.String(sig)
							if !input.ReadASN1(&inner, asn1.SEQUENCE) || func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:544
		_go_fuzz_dep_.CoverTab[9036]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:544
		return !input.Empty()
								// _ = "end of CoverTab[9036]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:545
	}() || func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:545
		_go_fuzz_dep_.CoverTab[9037]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:545
		return !inner.ReadASN1Integer(&r)
								// _ = "end of CoverTab[9037]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:546
	}() || func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:546
		_go_fuzz_dep_.CoverTab[9038]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:546
		return !inner.ReadASN1Integer(&s)
								// _ = "end of CoverTab[9038]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:547
	}() || func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:547
		_go_fuzz_dep_.CoverTab[9039]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:547
		return !inner.Empty()
								// _ = "end of CoverTab[9039]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:548
	}() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:548
		_go_fuzz_dep_.CoverTab[9040]++
								return nil, nil, errors.New("invalid ASN.1")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:549
		// _ = "end of CoverTab[9040]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:550
		_go_fuzz_dep_.CoverTab[9041]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:550
		// _ = "end of CoverTab[9041]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:550
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:550
	// _ = "end of CoverTab[9034]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:550
	_go_fuzz_dep_.CoverTab[9035]++
							return r, s, nil
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:551
	// _ = "end of CoverTab[9035]"
}

type nistCurve[Point nistPoint[Point]] struct {
	newPoint	func() Point
	curve		elliptic.Curve
	N		*bigmod.Modulus
	nMinus2		[]byte
}

// nistPoint is a generic constraint for the nistec Point types.
type nistPoint[T any] interface {
	Bytes() []byte
	BytesX() ([]byte, error)
	SetBytes([]byte) (T, error)
	Add(T, T) T
	ScalarMult(T, []byte) (T, error)
	ScalarBaseMult([]byte) (T, error)
}

// pointFromAffine is used to convert the PublicKey to a nistec Point.
func (curve *nistCurve[Point]) pointFromAffine(x, y *big.Int) (p Point, err error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:572
	_go_fuzz_dep_.CoverTab[9042]++
							bitSize := curve.curve.Params().BitSize

							if x.Sign() < 0 || func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:575
		_go_fuzz_dep_.CoverTab[9045]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:575
		return y.Sign() < 0
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:575
		// _ = "end of CoverTab[9045]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:575
	}() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:575
		_go_fuzz_dep_.CoverTab[9046]++
								return p, errors.New("negative coordinate")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:576
		// _ = "end of CoverTab[9046]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:577
		_go_fuzz_dep_.CoverTab[9047]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:577
		// _ = "end of CoverTab[9047]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:577
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:577
	// _ = "end of CoverTab[9042]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:577
	_go_fuzz_dep_.CoverTab[9043]++
							if x.BitLen() > bitSize || func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:578
		_go_fuzz_dep_.CoverTab[9048]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:578
		return y.BitLen() > bitSize
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:578
		// _ = "end of CoverTab[9048]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:578
	}() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:578
		_go_fuzz_dep_.CoverTab[9049]++
								return p, errors.New("overflowing coordinate")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:579
		// _ = "end of CoverTab[9049]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:580
		_go_fuzz_dep_.CoverTab[9050]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:580
		// _ = "end of CoverTab[9050]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:580
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:580
	// _ = "end of CoverTab[9043]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:580
	_go_fuzz_dep_.CoverTab[9044]++

							byteLen := (bitSize + 7) / 8
							buf := make([]byte, 1+2*byteLen)
							buf[0] = 4
							x.FillBytes(buf[1 : 1+byteLen])
							y.FillBytes(buf[1+byteLen : 1+2*byteLen])
							return curve.newPoint().SetBytes(buf)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:587
	// _ = "end of CoverTab[9044]"
}

// pointToAffine is used to convert a nistec Point to a PublicKey.
func (curve *nistCurve[Point]) pointToAffine(p Point) (x, y *big.Int, err error) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:591
	_go_fuzz_dep_.CoverTab[9051]++
							out := p.Bytes()
							if len(out) == 1 && func() bool {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:593
		_go_fuzz_dep_.CoverTab[9053]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:593
		return out[0] == 0
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:593
		// _ = "end of CoverTab[9053]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:593
	}() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:593
		_go_fuzz_dep_.CoverTab[9054]++

								return nil, nil, errors.New("ecdsa: public key point is the infinity")
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:595
		// _ = "end of CoverTab[9054]"
	} else {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:596
		_go_fuzz_dep_.CoverTab[9055]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:596
		// _ = "end of CoverTab[9055]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:596
	}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:596
	// _ = "end of CoverTab[9051]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:596
	_go_fuzz_dep_.CoverTab[9052]++
							byteLen := (curve.curve.Params().BitSize + 7) / 8
							x = new(big.Int).SetBytes(out[1 : 1+byteLen])
							y = new(big.Int).SetBytes(out[1+byteLen:])
							return x, y, nil
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:600
	// _ = "end of CoverTab[9052]"
}

var p224Once sync.Once
var _p224 *nistCurve[*nistec.P224Point]

func p224() *nistCurve[*nistec.P224Point] {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:606
	_go_fuzz_dep_.CoverTab[9056]++
							p224Once.Do(func() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:607
		_go_fuzz_dep_.CoverTab[9058]++
								_p224 = &nistCurve[*nistec.P224Point]{
			newPoint: func() *nistec.P224Point {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:609
				_go_fuzz_dep_.CoverTab[9060]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:609
				return nistec.NewP224Point()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:609
				// _ = "end of CoverTab[9060]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:609
			},
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:610
		// _ = "end of CoverTab[9058]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:610
		_go_fuzz_dep_.CoverTab[9059]++
								precomputeParams(_p224, elliptic.P224())
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:611
		// _ = "end of CoverTab[9059]"
	})
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:612
	// _ = "end of CoverTab[9056]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:612
	_go_fuzz_dep_.CoverTab[9057]++
							return _p224
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:613
	// _ = "end of CoverTab[9057]"
}

var p256Once sync.Once
var _p256 *nistCurve[*nistec.P256Point]

func p256() *nistCurve[*nistec.P256Point] {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:619
	_go_fuzz_dep_.CoverTab[9061]++
							p256Once.Do(func() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:620
		_go_fuzz_dep_.CoverTab[9063]++
								_p256 = &nistCurve[*nistec.P256Point]{
			newPoint: func() *nistec.P256Point {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:622
				_go_fuzz_dep_.CoverTab[9065]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:622
				return nistec.NewP256Point()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:622
				// _ = "end of CoverTab[9065]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:622
			},
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:623
		// _ = "end of CoverTab[9063]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:623
		_go_fuzz_dep_.CoverTab[9064]++
								precomputeParams(_p256, elliptic.P256())
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:624
		// _ = "end of CoverTab[9064]"
	})
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:625
	// _ = "end of CoverTab[9061]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:625
	_go_fuzz_dep_.CoverTab[9062]++
							return _p256
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:626
	// _ = "end of CoverTab[9062]"
}

var p384Once sync.Once
var _p384 *nistCurve[*nistec.P384Point]

func p384() *nistCurve[*nistec.P384Point] {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:632
	_go_fuzz_dep_.CoverTab[9066]++
							p384Once.Do(func() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:633
		_go_fuzz_dep_.CoverTab[9068]++
								_p384 = &nistCurve[*nistec.P384Point]{
			newPoint: func() *nistec.P384Point {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:635
				_go_fuzz_dep_.CoverTab[9070]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:635
				return nistec.NewP384Point()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:635
				// _ = "end of CoverTab[9070]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:635
			},
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:636
		// _ = "end of CoverTab[9068]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:636
		_go_fuzz_dep_.CoverTab[9069]++
								precomputeParams(_p384, elliptic.P384())
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:637
		// _ = "end of CoverTab[9069]"
	})
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:638
	// _ = "end of CoverTab[9066]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:638
	_go_fuzz_dep_.CoverTab[9067]++
							return _p384
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:639
	// _ = "end of CoverTab[9067]"
}

var p521Once sync.Once
var _p521 *nistCurve[*nistec.P521Point]

func p521() *nistCurve[*nistec.P521Point] {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:645
	_go_fuzz_dep_.CoverTab[9071]++
							p521Once.Do(func() {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:646
		_go_fuzz_dep_.CoverTab[9073]++
								_p521 = &nistCurve[*nistec.P521Point]{
			newPoint: func() *nistec.P521Point {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:648
				_go_fuzz_dep_.CoverTab[9075]++
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:648
				return nistec.NewP521Point()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:648
				// _ = "end of CoverTab[9075]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:648
			},
		}
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:649
		// _ = "end of CoverTab[9073]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:649
		_go_fuzz_dep_.CoverTab[9074]++
								precomputeParams(_p521, elliptic.P521())
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:650
		// _ = "end of CoverTab[9074]"
	})
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:651
	// _ = "end of CoverTab[9071]"
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:651
	_go_fuzz_dep_.CoverTab[9072]++
							return _p521
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:652
	// _ = "end of CoverTab[9072]"
}

func precomputeParams[Point nistPoint[Point]](c *nistCurve[Point], curve elliptic.Curve) {
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:655
	_go_fuzz_dep_.CoverTab[9076]++
							params := curve.Params()
							c.curve = curve
							c.N = bigmod.NewModulusFromBig(params.N)
							c.nMinus2 = new(big.Int).Sub(params.N, big.NewInt(2)).Bytes()
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:659
	// _ = "end of CoverTab[9076]"
}

//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:660
var _ = _atomic_.LoadUint32(&_go_fuzz_dep_.NoUse)
//line /usr/local/go/src/crypto/ecdsa/ecdsa.go:660
var _ = _go_fuzz_dep_.CoverTab
