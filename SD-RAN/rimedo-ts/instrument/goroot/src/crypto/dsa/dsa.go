// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//line /usr/local/go/src/crypto/dsa/dsa.go:5
// Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.
//line /usr/local/go/src/crypto/dsa/dsa.go:5
//
//line /usr/local/go/src/crypto/dsa/dsa.go:5
// The DSA operations in this package are not implemented using constant-time algorithms.
//line /usr/local/go/src/crypto/dsa/dsa.go:5
//
//line /usr/local/go/src/crypto/dsa/dsa.go:5
// Deprecated: DSA is a legacy algorithm, and modern alternatives such as
//line /usr/local/go/src/crypto/dsa/dsa.go:5
// Ed25519 (implemented by package crypto/ed25519) should be used instead. Keys
//line /usr/local/go/src/crypto/dsa/dsa.go:5
// with 1024-bit moduli (L1024N160 parameters) are cryptographically weak, while
//line /usr/local/go/src/crypto/dsa/dsa.go:5
// bigger keys are not widely supported. Note that FIPS 186-5 no longer approves
//line /usr/local/go/src/crypto/dsa/dsa.go:5
// DSA for signature generation.
//line /usr/local/go/src/crypto/dsa/dsa.go:14
package dsa

//line /usr/local/go/src/crypto/dsa/dsa.go:14
import (
//line /usr/local/go/src/crypto/dsa/dsa.go:14
	_go_fuzz_dep_ "go-fuzz-dep"
//line /usr/local/go/src/crypto/dsa/dsa.go:14
)
//line /usr/local/go/src/crypto/dsa/dsa.go:14
import (
//line /usr/local/go/src/crypto/dsa/dsa.go:14
	_atomic_ "sync/atomic"
//line /usr/local/go/src/crypto/dsa/dsa.go:14
)

import (
	"errors"
	"io"
	"math/big"

	"crypto/internal/randutil"
)

// Parameters represents the domain parameters for a key. These parameters can
//line /usr/local/go/src/crypto/dsa/dsa.go:24
// be shared across many keys. The bit length of Q must be a multiple of 8.
//line /usr/local/go/src/crypto/dsa/dsa.go:26
type Parameters struct {
	P, Q, G *big.Int
}

// PublicKey represents a DSA public key.
type PublicKey struct {
	Parameters
	Y	*big.Int
}

// PrivateKey represents a DSA private key.
type PrivateKey struct {
	PublicKey
	X	*big.Int
}

// ErrInvalidPublicKey results when a public key is not usable by this code.
//line /usr/local/go/src/crypto/dsa/dsa.go:42
// FIPS is quite strict about the format of DSA keys, but other code may be
//line /usr/local/go/src/crypto/dsa/dsa.go:42
// less so. Thus, when using keys which may have been generated by other code,
//line /usr/local/go/src/crypto/dsa/dsa.go:42
// this error must be handled.
//line /usr/local/go/src/crypto/dsa/dsa.go:46
var ErrInvalidPublicKey = errors.New("crypto/dsa: invalid public key")

// ParameterSizes is an enumeration of the acceptable bit lengths of the primes
//line /usr/local/go/src/crypto/dsa/dsa.go:48
// in a set of DSA parameters. See FIPS 186-3, section 4.2.
//line /usr/local/go/src/crypto/dsa/dsa.go:50
type ParameterSizes int

const (
	L1024N160	ParameterSizes	= iota
	L2048N224
	L2048N256
	L3072N256
)

// numMRTests is the number of Miller-Rabin primality tests that we perform. We
//line /usr/local/go/src/crypto/dsa/dsa.go:59
// pick the largest recommended number from table C.1 of FIPS 186-3.
//line /usr/local/go/src/crypto/dsa/dsa.go:61
const numMRTests = 64

// GenerateParameters puts a random, valid set of DSA parameters into params.
//line /usr/local/go/src/crypto/dsa/dsa.go:63
// This function can take many seconds, even on fast machines.
//line /usr/local/go/src/crypto/dsa/dsa.go:65
func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) error {
//line /usr/local/go/src/crypto/dsa/dsa.go:65
	_go_fuzz_dep_.CoverTab[10246]++

//line /usr/local/go/src/crypto/dsa/dsa.go:71
	var L, N int
	switch sizes {
	case L1024N160:
//line /usr/local/go/src/crypto/dsa/dsa.go:73
		_go_fuzz_dep_.CoverTab[10249]++
							L = 1024
							N = 160
//line /usr/local/go/src/crypto/dsa/dsa.go:75
		// _ = "end of CoverTab[10249]"
	case L2048N224:
//line /usr/local/go/src/crypto/dsa/dsa.go:76
		_go_fuzz_dep_.CoverTab[10250]++
							L = 2048
							N = 224
//line /usr/local/go/src/crypto/dsa/dsa.go:78
		// _ = "end of CoverTab[10250]"
	case L2048N256:
//line /usr/local/go/src/crypto/dsa/dsa.go:79
		_go_fuzz_dep_.CoverTab[10251]++
							L = 2048
							N = 256
//line /usr/local/go/src/crypto/dsa/dsa.go:81
		// _ = "end of CoverTab[10251]"
	case L3072N256:
//line /usr/local/go/src/crypto/dsa/dsa.go:82
		_go_fuzz_dep_.CoverTab[10252]++
							L = 3072
							N = 256
//line /usr/local/go/src/crypto/dsa/dsa.go:84
		// _ = "end of CoverTab[10252]"
	default:
//line /usr/local/go/src/crypto/dsa/dsa.go:85
		_go_fuzz_dep_.CoverTab[10253]++
							return errors.New("crypto/dsa: invalid ParameterSizes")
//line /usr/local/go/src/crypto/dsa/dsa.go:86
		// _ = "end of CoverTab[10253]"
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:87
	// _ = "end of CoverTab[10246]"
//line /usr/local/go/src/crypto/dsa/dsa.go:87
	_go_fuzz_dep_.CoverTab[10247]++

						qBytes := make([]byte, N/8)
						pBytes := make([]byte, L/8)

						q := new(big.Int)
						p := new(big.Int)
						rem := new(big.Int)
						one := new(big.Int)
						one.SetInt64(1)

GeneratePrimes:
	for {
//line /usr/local/go/src/crypto/dsa/dsa.go:99
		_go_fuzz_dep_.CoverTab[10254]++
							if _, err := io.ReadFull(rand, qBytes); err != nil {
//line /usr/local/go/src/crypto/dsa/dsa.go:100
			_go_fuzz_dep_.CoverTab[10257]++
								return err
//line /usr/local/go/src/crypto/dsa/dsa.go:101
			// _ = "end of CoverTab[10257]"
		} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:102
			_go_fuzz_dep_.CoverTab[10258]++
//line /usr/local/go/src/crypto/dsa/dsa.go:102
			// _ = "end of CoverTab[10258]"
//line /usr/local/go/src/crypto/dsa/dsa.go:102
		}
//line /usr/local/go/src/crypto/dsa/dsa.go:102
		// _ = "end of CoverTab[10254]"
//line /usr/local/go/src/crypto/dsa/dsa.go:102
		_go_fuzz_dep_.CoverTab[10255]++

							qBytes[len(qBytes)-1] |= 1
							qBytes[0] |= 0x80
							q.SetBytes(qBytes)

							if !q.ProbablyPrime(numMRTests) {
//line /usr/local/go/src/crypto/dsa/dsa.go:108
			_go_fuzz_dep_.CoverTab[10259]++
								continue
//line /usr/local/go/src/crypto/dsa/dsa.go:109
			// _ = "end of CoverTab[10259]"
		} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:110
			_go_fuzz_dep_.CoverTab[10260]++
//line /usr/local/go/src/crypto/dsa/dsa.go:110
			// _ = "end of CoverTab[10260]"
//line /usr/local/go/src/crypto/dsa/dsa.go:110
		}
//line /usr/local/go/src/crypto/dsa/dsa.go:110
		// _ = "end of CoverTab[10255]"
//line /usr/local/go/src/crypto/dsa/dsa.go:110
		_go_fuzz_dep_.CoverTab[10256]++

							for i := 0; i < 4*L; i++ {
//line /usr/local/go/src/crypto/dsa/dsa.go:112
			_go_fuzz_dep_.CoverTab[10261]++
								if _, err := io.ReadFull(rand, pBytes); err != nil {
//line /usr/local/go/src/crypto/dsa/dsa.go:113
				_go_fuzz_dep_.CoverTab[10265]++
									return err
//line /usr/local/go/src/crypto/dsa/dsa.go:114
				// _ = "end of CoverTab[10265]"
			} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:115
				_go_fuzz_dep_.CoverTab[10266]++
//line /usr/local/go/src/crypto/dsa/dsa.go:115
				// _ = "end of CoverTab[10266]"
//line /usr/local/go/src/crypto/dsa/dsa.go:115
			}
//line /usr/local/go/src/crypto/dsa/dsa.go:115
			// _ = "end of CoverTab[10261]"
//line /usr/local/go/src/crypto/dsa/dsa.go:115
			_go_fuzz_dep_.CoverTab[10262]++

								pBytes[len(pBytes)-1] |= 1
								pBytes[0] |= 0x80

								p.SetBytes(pBytes)
								rem.Mod(p, q)
								rem.Sub(rem, one)
								p.Sub(p, rem)
								if p.BitLen() < L {
//line /usr/local/go/src/crypto/dsa/dsa.go:124
				_go_fuzz_dep_.CoverTab[10267]++
									continue
//line /usr/local/go/src/crypto/dsa/dsa.go:125
				// _ = "end of CoverTab[10267]"
			} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:126
				_go_fuzz_dep_.CoverTab[10268]++
//line /usr/local/go/src/crypto/dsa/dsa.go:126
				// _ = "end of CoverTab[10268]"
//line /usr/local/go/src/crypto/dsa/dsa.go:126
			}
//line /usr/local/go/src/crypto/dsa/dsa.go:126
			// _ = "end of CoverTab[10262]"
//line /usr/local/go/src/crypto/dsa/dsa.go:126
			_go_fuzz_dep_.CoverTab[10263]++

								if !p.ProbablyPrime(numMRTests) {
//line /usr/local/go/src/crypto/dsa/dsa.go:128
				_go_fuzz_dep_.CoverTab[10269]++
									continue
//line /usr/local/go/src/crypto/dsa/dsa.go:129
				// _ = "end of CoverTab[10269]"
			} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:130
				_go_fuzz_dep_.CoverTab[10270]++
//line /usr/local/go/src/crypto/dsa/dsa.go:130
				// _ = "end of CoverTab[10270]"
//line /usr/local/go/src/crypto/dsa/dsa.go:130
			}
//line /usr/local/go/src/crypto/dsa/dsa.go:130
			// _ = "end of CoverTab[10263]"
//line /usr/local/go/src/crypto/dsa/dsa.go:130
			_go_fuzz_dep_.CoverTab[10264]++

								params.P = p
								params.Q = q
								break GeneratePrimes
//line /usr/local/go/src/crypto/dsa/dsa.go:134
			// _ = "end of CoverTab[10264]"
		}
//line /usr/local/go/src/crypto/dsa/dsa.go:135
		// _ = "end of CoverTab[10256]"
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:136
	// _ = "end of CoverTab[10247]"
//line /usr/local/go/src/crypto/dsa/dsa.go:136
	_go_fuzz_dep_.CoverTab[10248]++

						h := new(big.Int)
						h.SetInt64(2)
						g := new(big.Int)

						pm1 := new(big.Int).Sub(p, one)
						e := new(big.Int).Div(pm1, q)

						for {
//line /usr/local/go/src/crypto/dsa/dsa.go:145
		_go_fuzz_dep_.CoverTab[10271]++
							g.Exp(h, e, p)
							if g.Cmp(one) == 0 {
//line /usr/local/go/src/crypto/dsa/dsa.go:147
			_go_fuzz_dep_.CoverTab[10273]++
								h.Add(h, one)
								continue
//line /usr/local/go/src/crypto/dsa/dsa.go:149
			// _ = "end of CoverTab[10273]"
		} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:150
			_go_fuzz_dep_.CoverTab[10274]++
//line /usr/local/go/src/crypto/dsa/dsa.go:150
			// _ = "end of CoverTab[10274]"
//line /usr/local/go/src/crypto/dsa/dsa.go:150
		}
//line /usr/local/go/src/crypto/dsa/dsa.go:150
		// _ = "end of CoverTab[10271]"
//line /usr/local/go/src/crypto/dsa/dsa.go:150
		_go_fuzz_dep_.CoverTab[10272]++

							params.G = g
							return nil
//line /usr/local/go/src/crypto/dsa/dsa.go:153
		// _ = "end of CoverTab[10272]"
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:154
	// _ = "end of CoverTab[10248]"
}

// GenerateKey generates a public&private key pair. The Parameters of the
//line /usr/local/go/src/crypto/dsa/dsa.go:157
// PrivateKey must already be valid (see GenerateParameters).
//line /usr/local/go/src/crypto/dsa/dsa.go:159
func GenerateKey(priv *PrivateKey, rand io.Reader) error {
//line /usr/local/go/src/crypto/dsa/dsa.go:159
	_go_fuzz_dep_.CoverTab[10275]++
						if priv.P == nil || func() bool {
//line /usr/local/go/src/crypto/dsa/dsa.go:160
		_go_fuzz_dep_.CoverTab[10278]++
//line /usr/local/go/src/crypto/dsa/dsa.go:160
		return priv.Q == nil
//line /usr/local/go/src/crypto/dsa/dsa.go:160
		// _ = "end of CoverTab[10278]"
//line /usr/local/go/src/crypto/dsa/dsa.go:160
	}() || func() bool {
//line /usr/local/go/src/crypto/dsa/dsa.go:160
		_go_fuzz_dep_.CoverTab[10279]++
//line /usr/local/go/src/crypto/dsa/dsa.go:160
		return priv.G == nil
//line /usr/local/go/src/crypto/dsa/dsa.go:160
		// _ = "end of CoverTab[10279]"
//line /usr/local/go/src/crypto/dsa/dsa.go:160
	}() {
//line /usr/local/go/src/crypto/dsa/dsa.go:160
		_go_fuzz_dep_.CoverTab[10280]++
							return errors.New("crypto/dsa: parameters not set up before generating key")
//line /usr/local/go/src/crypto/dsa/dsa.go:161
		// _ = "end of CoverTab[10280]"
	} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:162
		_go_fuzz_dep_.CoverTab[10281]++
//line /usr/local/go/src/crypto/dsa/dsa.go:162
		// _ = "end of CoverTab[10281]"
//line /usr/local/go/src/crypto/dsa/dsa.go:162
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:162
	// _ = "end of CoverTab[10275]"
//line /usr/local/go/src/crypto/dsa/dsa.go:162
	_go_fuzz_dep_.CoverTab[10276]++

						x := new(big.Int)
						xBytes := make([]byte, priv.Q.BitLen()/8)

						for {
//line /usr/local/go/src/crypto/dsa/dsa.go:167
		_go_fuzz_dep_.CoverTab[10282]++
							_, err := io.ReadFull(rand, xBytes)
							if err != nil {
//line /usr/local/go/src/crypto/dsa/dsa.go:169
			_go_fuzz_dep_.CoverTab[10284]++
								return err
//line /usr/local/go/src/crypto/dsa/dsa.go:170
			// _ = "end of CoverTab[10284]"
		} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:171
			_go_fuzz_dep_.CoverTab[10285]++
//line /usr/local/go/src/crypto/dsa/dsa.go:171
			// _ = "end of CoverTab[10285]"
//line /usr/local/go/src/crypto/dsa/dsa.go:171
		}
//line /usr/local/go/src/crypto/dsa/dsa.go:171
		// _ = "end of CoverTab[10282]"
//line /usr/local/go/src/crypto/dsa/dsa.go:171
		_go_fuzz_dep_.CoverTab[10283]++
							x.SetBytes(xBytes)
							if x.Sign() != 0 && func() bool {
//line /usr/local/go/src/crypto/dsa/dsa.go:173
			_go_fuzz_dep_.CoverTab[10286]++
//line /usr/local/go/src/crypto/dsa/dsa.go:173
			return x.Cmp(priv.Q) < 0
//line /usr/local/go/src/crypto/dsa/dsa.go:173
			// _ = "end of CoverTab[10286]"
//line /usr/local/go/src/crypto/dsa/dsa.go:173
		}() {
//line /usr/local/go/src/crypto/dsa/dsa.go:173
			_go_fuzz_dep_.CoverTab[10287]++
								break
//line /usr/local/go/src/crypto/dsa/dsa.go:174
			// _ = "end of CoverTab[10287]"
		} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:175
			_go_fuzz_dep_.CoverTab[10288]++
//line /usr/local/go/src/crypto/dsa/dsa.go:175
			// _ = "end of CoverTab[10288]"
//line /usr/local/go/src/crypto/dsa/dsa.go:175
		}
//line /usr/local/go/src/crypto/dsa/dsa.go:175
		// _ = "end of CoverTab[10283]"
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:176
	// _ = "end of CoverTab[10276]"
//line /usr/local/go/src/crypto/dsa/dsa.go:176
	_go_fuzz_dep_.CoverTab[10277]++

						priv.X = x
						priv.Y = new(big.Int)
						priv.Y.Exp(priv.G, x, priv.P)
						return nil
//line /usr/local/go/src/crypto/dsa/dsa.go:181
	// _ = "end of CoverTab[10277]"
}

// fermatInverse calculates the inverse of k in GF(P) using Fermat's method.
//line /usr/local/go/src/crypto/dsa/dsa.go:184
// This has better constant-time properties than Euclid's method (implemented
//line /usr/local/go/src/crypto/dsa/dsa.go:184
// in math/big.Int.ModInverse) although math/big itself isn't strictly
//line /usr/local/go/src/crypto/dsa/dsa.go:184
// constant-time so it's not perfect.
//line /usr/local/go/src/crypto/dsa/dsa.go:188
func fermatInverse(k, P *big.Int) *big.Int {
//line /usr/local/go/src/crypto/dsa/dsa.go:188
	_go_fuzz_dep_.CoverTab[10289]++
						two := big.NewInt(2)
						pMinus2 := new(big.Int).Sub(P, two)
						return new(big.Int).Exp(k, pMinus2, P)
//line /usr/local/go/src/crypto/dsa/dsa.go:191
	// _ = "end of CoverTab[10289]"
}

// Sign signs an arbitrary length hash (which should be the result of hashing a
//line /usr/local/go/src/crypto/dsa/dsa.go:194
// larger message) using the private key, priv. It returns the signature as a
//line /usr/local/go/src/crypto/dsa/dsa.go:194
// pair of integers. The security of the private key depends on the entropy of
//line /usr/local/go/src/crypto/dsa/dsa.go:194
// rand.
//line /usr/local/go/src/crypto/dsa/dsa.go:194
//
//line /usr/local/go/src/crypto/dsa/dsa.go:194
// Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated
//line /usr/local/go/src/crypto/dsa/dsa.go:194
// to the byte-length of the subgroup. This function does not perform that
//line /usr/local/go/src/crypto/dsa/dsa.go:194
// truncation itself.
//line /usr/local/go/src/crypto/dsa/dsa.go:194
//
//line /usr/local/go/src/crypto/dsa/dsa.go:194
// Be aware that calling Sign with an attacker-controlled PrivateKey may
//line /usr/local/go/src/crypto/dsa/dsa.go:194
// require an arbitrary amount of CPU.
//line /usr/local/go/src/crypto/dsa/dsa.go:205
func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {
//line /usr/local/go/src/crypto/dsa/dsa.go:205
	_go_fuzz_dep_.CoverTab[10290]++
						randutil.MaybeReadByte(rand)

//line /usr/local/go/src/crypto/dsa/dsa.go:210
	n := priv.Q.BitLen()
	if priv.Q.Sign() <= 0 || func() bool {
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		_go_fuzz_dep_.CoverTab[10294]++
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		return priv.P.Sign() <= 0
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		// _ = "end of CoverTab[10294]"
//line /usr/local/go/src/crypto/dsa/dsa.go:211
	}() || func() bool {
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		_go_fuzz_dep_.CoverTab[10295]++
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		return priv.G.Sign() <= 0
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		// _ = "end of CoverTab[10295]"
//line /usr/local/go/src/crypto/dsa/dsa.go:211
	}() || func() bool {
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		_go_fuzz_dep_.CoverTab[10296]++
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		return priv.X.Sign() <= 0
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		// _ = "end of CoverTab[10296]"
//line /usr/local/go/src/crypto/dsa/dsa.go:211
	}() || func() bool {
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		_go_fuzz_dep_.CoverTab[10297]++
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		return n%8 != 0
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		// _ = "end of CoverTab[10297]"
//line /usr/local/go/src/crypto/dsa/dsa.go:211
	}() {
//line /usr/local/go/src/crypto/dsa/dsa.go:211
		_go_fuzz_dep_.CoverTab[10298]++
							err = ErrInvalidPublicKey
							return
//line /usr/local/go/src/crypto/dsa/dsa.go:213
		// _ = "end of CoverTab[10298]"
	} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:214
		_go_fuzz_dep_.CoverTab[10299]++
//line /usr/local/go/src/crypto/dsa/dsa.go:214
		// _ = "end of CoverTab[10299]"
//line /usr/local/go/src/crypto/dsa/dsa.go:214
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:214
	// _ = "end of CoverTab[10290]"
//line /usr/local/go/src/crypto/dsa/dsa.go:214
	_go_fuzz_dep_.CoverTab[10291]++
						n >>= 3

						var attempts int
						for attempts = 10; attempts > 0; attempts-- {
//line /usr/local/go/src/crypto/dsa/dsa.go:218
		_go_fuzz_dep_.CoverTab[10300]++
							k := new(big.Int)
							buf := make([]byte, n)
							for {
//line /usr/local/go/src/crypto/dsa/dsa.go:221
			_go_fuzz_dep_.CoverTab[10303]++
								_, err = io.ReadFull(rand, buf)
								if err != nil {
//line /usr/local/go/src/crypto/dsa/dsa.go:223
				_go_fuzz_dep_.CoverTab[10305]++
									return
//line /usr/local/go/src/crypto/dsa/dsa.go:224
				// _ = "end of CoverTab[10305]"
			} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:225
				_go_fuzz_dep_.CoverTab[10306]++
//line /usr/local/go/src/crypto/dsa/dsa.go:225
				// _ = "end of CoverTab[10306]"
//line /usr/local/go/src/crypto/dsa/dsa.go:225
			}
//line /usr/local/go/src/crypto/dsa/dsa.go:225
			// _ = "end of CoverTab[10303]"
//line /usr/local/go/src/crypto/dsa/dsa.go:225
			_go_fuzz_dep_.CoverTab[10304]++
								k.SetBytes(buf)

//line /usr/local/go/src/crypto/dsa/dsa.go:231
			if k.Sign() > 0 && func() bool {
//line /usr/local/go/src/crypto/dsa/dsa.go:231
				_go_fuzz_dep_.CoverTab[10307]++
//line /usr/local/go/src/crypto/dsa/dsa.go:231
				return k.Cmp(priv.Q) < 0
//line /usr/local/go/src/crypto/dsa/dsa.go:231
				// _ = "end of CoverTab[10307]"
//line /usr/local/go/src/crypto/dsa/dsa.go:231
			}() {
//line /usr/local/go/src/crypto/dsa/dsa.go:231
				_go_fuzz_dep_.CoverTab[10308]++
									break
//line /usr/local/go/src/crypto/dsa/dsa.go:232
				// _ = "end of CoverTab[10308]"
			} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:233
				_go_fuzz_dep_.CoverTab[10309]++
//line /usr/local/go/src/crypto/dsa/dsa.go:233
				// _ = "end of CoverTab[10309]"
//line /usr/local/go/src/crypto/dsa/dsa.go:233
			}
//line /usr/local/go/src/crypto/dsa/dsa.go:233
			// _ = "end of CoverTab[10304]"
		}
//line /usr/local/go/src/crypto/dsa/dsa.go:234
		// _ = "end of CoverTab[10300]"
//line /usr/local/go/src/crypto/dsa/dsa.go:234
		_go_fuzz_dep_.CoverTab[10301]++

							kInv := fermatInverse(k, priv.Q)

							r = new(big.Int).Exp(priv.G, k, priv.P)
							r.Mod(r, priv.Q)

							if r.Sign() == 0 {
//line /usr/local/go/src/crypto/dsa/dsa.go:241
			_go_fuzz_dep_.CoverTab[10310]++
								continue
//line /usr/local/go/src/crypto/dsa/dsa.go:242
			// _ = "end of CoverTab[10310]"
		} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:243
			_go_fuzz_dep_.CoverTab[10311]++
//line /usr/local/go/src/crypto/dsa/dsa.go:243
			// _ = "end of CoverTab[10311]"
//line /usr/local/go/src/crypto/dsa/dsa.go:243
		}
//line /usr/local/go/src/crypto/dsa/dsa.go:243
		// _ = "end of CoverTab[10301]"
//line /usr/local/go/src/crypto/dsa/dsa.go:243
		_go_fuzz_dep_.CoverTab[10302]++

							z := k.SetBytes(hash)

							s = new(big.Int).Mul(priv.X, r)
							s.Add(s, z)
							s.Mod(s, priv.Q)
							s.Mul(s, kInv)
							s.Mod(s, priv.Q)

							if s.Sign() != 0 {
//line /usr/local/go/src/crypto/dsa/dsa.go:253
			_go_fuzz_dep_.CoverTab[10312]++
								break
//line /usr/local/go/src/crypto/dsa/dsa.go:254
			// _ = "end of CoverTab[10312]"
		} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:255
			_go_fuzz_dep_.CoverTab[10313]++
//line /usr/local/go/src/crypto/dsa/dsa.go:255
			// _ = "end of CoverTab[10313]"
//line /usr/local/go/src/crypto/dsa/dsa.go:255
		}
//line /usr/local/go/src/crypto/dsa/dsa.go:255
		// _ = "end of CoverTab[10302]"
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:256
	// _ = "end of CoverTab[10291]"
//line /usr/local/go/src/crypto/dsa/dsa.go:256
	_go_fuzz_dep_.CoverTab[10292]++

//line /usr/local/go/src/crypto/dsa/dsa.go:260
	if attempts == 0 {
//line /usr/local/go/src/crypto/dsa/dsa.go:260
		_go_fuzz_dep_.CoverTab[10314]++
							return nil, nil, ErrInvalidPublicKey
//line /usr/local/go/src/crypto/dsa/dsa.go:261
		// _ = "end of CoverTab[10314]"
	} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:262
		_go_fuzz_dep_.CoverTab[10315]++
//line /usr/local/go/src/crypto/dsa/dsa.go:262
		// _ = "end of CoverTab[10315]"
//line /usr/local/go/src/crypto/dsa/dsa.go:262
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:262
	// _ = "end of CoverTab[10292]"
//line /usr/local/go/src/crypto/dsa/dsa.go:262
	_go_fuzz_dep_.CoverTab[10293]++

						return
//line /usr/local/go/src/crypto/dsa/dsa.go:264
	// _ = "end of CoverTab[10293]"
}

// Verify verifies the signature in r, s of hash using the public key, pub. It
//line /usr/local/go/src/crypto/dsa/dsa.go:267
// reports whether the signature is valid.
//line /usr/local/go/src/crypto/dsa/dsa.go:267
//
//line /usr/local/go/src/crypto/dsa/dsa.go:267
// Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated
//line /usr/local/go/src/crypto/dsa/dsa.go:267
// to the byte-length of the subgroup. This function does not perform that
//line /usr/local/go/src/crypto/dsa/dsa.go:267
// truncation itself.
//line /usr/local/go/src/crypto/dsa/dsa.go:273
func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
//line /usr/local/go/src/crypto/dsa/dsa.go:273
	_go_fuzz_dep_.CoverTab[10316]++

//line /usr/local/go/src/crypto/dsa/dsa.go:276
	if pub.P.Sign() == 0 {
//line /usr/local/go/src/crypto/dsa/dsa.go:276
		_go_fuzz_dep_.CoverTab[10322]++
							return false
//line /usr/local/go/src/crypto/dsa/dsa.go:277
		// _ = "end of CoverTab[10322]"
	} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:278
		_go_fuzz_dep_.CoverTab[10323]++
//line /usr/local/go/src/crypto/dsa/dsa.go:278
		// _ = "end of CoverTab[10323]"
//line /usr/local/go/src/crypto/dsa/dsa.go:278
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:278
	// _ = "end of CoverTab[10316]"
//line /usr/local/go/src/crypto/dsa/dsa.go:278
	_go_fuzz_dep_.CoverTab[10317]++

						if r.Sign() < 1 || func() bool {
//line /usr/local/go/src/crypto/dsa/dsa.go:280
		_go_fuzz_dep_.CoverTab[10324]++
//line /usr/local/go/src/crypto/dsa/dsa.go:280
		return r.Cmp(pub.Q) >= 0
//line /usr/local/go/src/crypto/dsa/dsa.go:280
		// _ = "end of CoverTab[10324]"
//line /usr/local/go/src/crypto/dsa/dsa.go:280
	}() {
//line /usr/local/go/src/crypto/dsa/dsa.go:280
		_go_fuzz_dep_.CoverTab[10325]++
							return false
//line /usr/local/go/src/crypto/dsa/dsa.go:281
		// _ = "end of CoverTab[10325]"
	} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:282
		_go_fuzz_dep_.CoverTab[10326]++
//line /usr/local/go/src/crypto/dsa/dsa.go:282
		// _ = "end of CoverTab[10326]"
//line /usr/local/go/src/crypto/dsa/dsa.go:282
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:282
	// _ = "end of CoverTab[10317]"
//line /usr/local/go/src/crypto/dsa/dsa.go:282
	_go_fuzz_dep_.CoverTab[10318]++
						if s.Sign() < 1 || func() bool {
//line /usr/local/go/src/crypto/dsa/dsa.go:283
		_go_fuzz_dep_.CoverTab[10327]++
//line /usr/local/go/src/crypto/dsa/dsa.go:283
		return s.Cmp(pub.Q) >= 0
//line /usr/local/go/src/crypto/dsa/dsa.go:283
		// _ = "end of CoverTab[10327]"
//line /usr/local/go/src/crypto/dsa/dsa.go:283
	}() {
//line /usr/local/go/src/crypto/dsa/dsa.go:283
		_go_fuzz_dep_.CoverTab[10328]++
							return false
//line /usr/local/go/src/crypto/dsa/dsa.go:284
		// _ = "end of CoverTab[10328]"
	} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:285
		_go_fuzz_dep_.CoverTab[10329]++
//line /usr/local/go/src/crypto/dsa/dsa.go:285
		// _ = "end of CoverTab[10329]"
//line /usr/local/go/src/crypto/dsa/dsa.go:285
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:285
	// _ = "end of CoverTab[10318]"
//line /usr/local/go/src/crypto/dsa/dsa.go:285
	_go_fuzz_dep_.CoverTab[10319]++

						w := new(big.Int).ModInverse(s, pub.Q)
						if w == nil {
//line /usr/local/go/src/crypto/dsa/dsa.go:288
		_go_fuzz_dep_.CoverTab[10330]++
							return false
//line /usr/local/go/src/crypto/dsa/dsa.go:289
		// _ = "end of CoverTab[10330]"
	} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:290
		_go_fuzz_dep_.CoverTab[10331]++
//line /usr/local/go/src/crypto/dsa/dsa.go:290
		// _ = "end of CoverTab[10331]"
//line /usr/local/go/src/crypto/dsa/dsa.go:290
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:290
	// _ = "end of CoverTab[10319]"
//line /usr/local/go/src/crypto/dsa/dsa.go:290
	_go_fuzz_dep_.CoverTab[10320]++

						n := pub.Q.BitLen()
						if n%8 != 0 {
//line /usr/local/go/src/crypto/dsa/dsa.go:293
		_go_fuzz_dep_.CoverTab[10332]++
							return false
//line /usr/local/go/src/crypto/dsa/dsa.go:294
		// _ = "end of CoverTab[10332]"
	} else {
//line /usr/local/go/src/crypto/dsa/dsa.go:295
		_go_fuzz_dep_.CoverTab[10333]++
//line /usr/local/go/src/crypto/dsa/dsa.go:295
		// _ = "end of CoverTab[10333]"
//line /usr/local/go/src/crypto/dsa/dsa.go:295
	}
//line /usr/local/go/src/crypto/dsa/dsa.go:295
	// _ = "end of CoverTab[10320]"
//line /usr/local/go/src/crypto/dsa/dsa.go:295
	_go_fuzz_dep_.CoverTab[10321]++
						z := new(big.Int).SetBytes(hash)

						u1 := new(big.Int).Mul(z, w)
						u1.Mod(u1, pub.Q)
						u2 := w.Mul(r, w)
						u2.Mod(u2, pub.Q)
						v := u1.Exp(pub.G, u1, pub.P)
						u2.Exp(pub.Y, u2, pub.P)
						v.Mul(v, u2)
						v.Mod(v, pub.P)
						v.Mod(v, pub.Q)

						return v.Cmp(r) == 0
//line /usr/local/go/src/crypto/dsa/dsa.go:308
	// _ = "end of CoverTab[10321]"
}

//line /usr/local/go/src/crypto/dsa/dsa.go:309
var _ = _atomic_.LoadUint32(&_go_fuzz_dep_.NoUse)
//line /usr/local/go/src/crypto/dsa/dsa.go:309
var _ = _go_fuzz_dep_.CoverTab
