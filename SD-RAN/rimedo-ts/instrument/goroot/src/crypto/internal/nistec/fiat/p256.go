// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by generate.go. DO NOT EDIT.

//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:7
package fiat

//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:7
import (
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:7
	_go_fuzz_dep_ "go-fuzz-dep"
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:7
)
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:7
import (
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:7
	_atomic_ "sync/atomic"
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:7
)

import (
	"crypto/subtle"
	"errors"
)

// P256Element is an integer modulo 2^256 - 2^224 + 2^192 + 2^96 - 1.
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:14
//
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:14
// The zero value is a valid zero element.
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:17
type P256Element struct {
	// Values are represented internally always in the Montgomery domain, and
	// converted in Bytes and SetBytes.
	x p256MontgomeryDomainFieldElement
}

const p256ElementLen = 32

type p256UntypedFieldElement = [4]uint64

// One sets e = 1, and returns e.
func (e *P256Element) One() *P256Element {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:28
	_go_fuzz_dep_.CoverTab[2107]++
									p256SetOne(&e.x)
									return e
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:30
	// _ = "end of CoverTab[2107]"
}

// Equal returns 1 if e == t, and zero otherwise.
func (e *P256Element) Equal(t *P256Element) int {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:34
	_go_fuzz_dep_.CoverTab[2108]++
									eBytes := e.Bytes()
									tBytes := t.Bytes()
									return subtle.ConstantTimeCompare(eBytes, tBytes)
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:37
	// _ = "end of CoverTab[2108]"
}

// IsZero returns 1 if e == 0, and zero otherwise.
func (e *P256Element) IsZero() int {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:41
	_go_fuzz_dep_.CoverTab[2109]++
									zero := make([]byte, p256ElementLen)
									eBytes := e.Bytes()
									return subtle.ConstantTimeCompare(eBytes, zero)
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:44
	// _ = "end of CoverTab[2109]"
}

// Set sets e = t, and returns e.
func (e *P256Element) Set(t *P256Element) *P256Element {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:48
	_go_fuzz_dep_.CoverTab[2110]++
									e.x = t.x
									return e
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:50
	// _ = "end of CoverTab[2110]"
}

// Bytes returns the 32-byte big-endian encoding of e.
func (e *P256Element) Bytes() []byte {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:54
	_go_fuzz_dep_.CoverTab[2111]++
	// This function is outlined to make the allocations inline in the caller
									// rather than happen on the heap.
									var out [p256ElementLen]byte
									return e.bytes(&out)
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:58
	// _ = "end of CoverTab[2111]"
}

func (e *P256Element) bytes(out *[p256ElementLen]byte) []byte {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:61
	_go_fuzz_dep_.CoverTab[2112]++
									var tmp p256NonMontgomeryDomainFieldElement
									p256FromMontgomery(&tmp, &e.x)
									p256ToBytes(out, (*p256UntypedFieldElement)(&tmp))
									p256InvertEndianness(out[:])
									return out[:]
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:66
	// _ = "end of CoverTab[2112]"
}

// SetBytes sets e = v, where v is a big-endian 32-byte encoding, and returns e.
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:69
// If v is not 32 bytes or it encodes a value higher than 2^256 - 2^224 + 2^192 + 2^96 - 1,
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:69
// SetBytes returns nil and an error, and e is unchanged.
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:72
func (e *P256Element) SetBytes(v []byte) (*P256Element, error) {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:72
	_go_fuzz_dep_.CoverTab[2113]++
									if len(v) != p256ElementLen {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:73
		_go_fuzz_dep_.CoverTab[2116]++
										return nil, errors.New("invalid P256Element encoding")
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:74
		// _ = "end of CoverTab[2116]"
	} else {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:75
		_go_fuzz_dep_.CoverTab[2117]++
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:75
		// _ = "end of CoverTab[2117]"
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:75
	}
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:75
	// _ = "end of CoverTab[2113]"
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:75
	_go_fuzz_dep_.CoverTab[2114]++

	// Check for non-canonical encodings (p + k, 2p + k, etc.) by comparing to
	// the encoding of -1 mod p, so p - 1, the highest canonical encoding.
	var minusOneEncoding = new(P256Element).Sub(
		new(P256Element), new(P256Element).One()).Bytes()
	for i := range v {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:81
		_go_fuzz_dep_.CoverTab[2118]++
										if v[i] < minusOneEncoding[i] {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:82
			_go_fuzz_dep_.CoverTab[2120]++
											break
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:83
			// _ = "end of CoverTab[2120]"
		} else {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:84
			_go_fuzz_dep_.CoverTab[2121]++
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:84
			// _ = "end of CoverTab[2121]"
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:84
		}
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:84
		// _ = "end of CoverTab[2118]"
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:84
		_go_fuzz_dep_.CoverTab[2119]++
										if v[i] > minusOneEncoding[i] {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:85
			_go_fuzz_dep_.CoverTab[2122]++
											return nil, errors.New("invalid P256Element encoding")
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:86
			// _ = "end of CoverTab[2122]"
		} else {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:87
			_go_fuzz_dep_.CoverTab[2123]++
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:87
			// _ = "end of CoverTab[2123]"
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:87
		}
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:87
		// _ = "end of CoverTab[2119]"
	}
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:88
	// _ = "end of CoverTab[2114]"
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:88
	_go_fuzz_dep_.CoverTab[2115]++

									var in [p256ElementLen]byte
									copy(in[:], v)
									p256InvertEndianness(in[:])
									var tmp p256NonMontgomeryDomainFieldElement
									p256FromBytes((*p256UntypedFieldElement)(&tmp), &in)
									p256ToMontgomery(&e.x, &tmp)
									return e, nil
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:96
	// _ = "end of CoverTab[2115]"
}

// Add sets e = t1 + t2, and returns e.
func (e *P256Element) Add(t1, t2 *P256Element) *P256Element {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:100
	_go_fuzz_dep_.CoverTab[2124]++
									p256Add(&e.x, &t1.x, &t2.x)
									return e
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:102
	// _ = "end of CoverTab[2124]"
}

// Sub sets e = t1 - t2, and returns e.
func (e *P256Element) Sub(t1, t2 *P256Element) *P256Element {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:106
	_go_fuzz_dep_.CoverTab[2125]++
									p256Sub(&e.x, &t1.x, &t2.x)
									return e
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:108
	// _ = "end of CoverTab[2125]"
}

// Mul sets e = t1 * t2, and returns e.
func (e *P256Element) Mul(t1, t2 *P256Element) *P256Element {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:112
	_go_fuzz_dep_.CoverTab[2126]++
									p256Mul(&e.x, &t1.x, &t2.x)
									return e
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:114
	// _ = "end of CoverTab[2126]"
}

// Square sets e = t * t, and returns e.
func (e *P256Element) Square(t *P256Element) *P256Element {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:118
	_go_fuzz_dep_.CoverTab[2127]++
									p256Square(&e.x, &t.x)
									return e
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:120
	// _ = "end of CoverTab[2127]"
}

// Select sets v to a if cond == 1, and to b if cond == 0.
func (v *P256Element) Select(a, b *P256Element, cond int) *P256Element {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:124
	_go_fuzz_dep_.CoverTab[2128]++
									p256Selectznz((*p256UntypedFieldElement)(&v.x), p256Uint1(cond),
		(*p256UntypedFieldElement)(&b.x), (*p256UntypedFieldElement)(&a.x))
									return v
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:127
	// _ = "end of CoverTab[2128]"
}

func p256InvertEndianness(v []byte) {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:130
	_go_fuzz_dep_.CoverTab[2129]++
									for i := 0; i < len(v)/2; i++ {
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:131
		_go_fuzz_dep_.CoverTab[2130]++
										v[i], v[len(v)-1-i] = v[len(v)-1-i], v[i]
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:132
		// _ = "end of CoverTab[2130]"
	}
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:133
	// _ = "end of CoverTab[2129]"
}

//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:134
var _ = _atomic_.LoadUint32(&_go_fuzz_dep_.NoUse)
//line /usr/local/go/src/crypto/internal/nistec/fiat/p256.go:134
var _ = _go_fuzz_dep_.CoverTab
