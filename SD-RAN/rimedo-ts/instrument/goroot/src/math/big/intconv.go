// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file implements int-to-string conversion functions.

//line /usr/local/go/src/math/big/intconv.go:7
package big

//line /usr/local/go/src/math/big/intconv.go:7
import (
//line /usr/local/go/src/math/big/intconv.go:7
	_go_fuzz_dep_ "go-fuzz-dep"
//line /usr/local/go/src/math/big/intconv.go:7
)
//line /usr/local/go/src/math/big/intconv.go:7
import (
//line /usr/local/go/src/math/big/intconv.go:7
	_atomic_ "sync/atomic"
//line /usr/local/go/src/math/big/intconv.go:7
)

import (
	"errors"
	"fmt"
	"io"
)

// Text returns the string representation of x in the given base.
//line /usr/local/go/src/math/big/intconv.go:15
// Base must be between 2 and 62, inclusive. The result uses the
//line /usr/local/go/src/math/big/intconv.go:15
// lower-case letters 'a' to 'z' for digit values 10 to 35, and
//line /usr/local/go/src/math/big/intconv.go:15
// the upper-case letters 'A' to 'Z' for digit values 36 to 61.
//line /usr/local/go/src/math/big/intconv.go:15
// No prefix (such as "0x") is added to the string. If x is a nil
//line /usr/local/go/src/math/big/intconv.go:15
// pointer it returns "<nil>".
//line /usr/local/go/src/math/big/intconv.go:21
func (x *Int) Text(base int) string {
//line /usr/local/go/src/math/big/intconv.go:21
	_go_fuzz_dep_.CoverTab[5552]++
							if x == nil {
//line /usr/local/go/src/math/big/intconv.go:22
		_go_fuzz_dep_.CoverTab[5554]++
								return "<nil>"
//line /usr/local/go/src/math/big/intconv.go:23
		// _ = "end of CoverTab[5554]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:24
		_go_fuzz_dep_.CoverTab[5555]++
//line /usr/local/go/src/math/big/intconv.go:24
		// _ = "end of CoverTab[5555]"
//line /usr/local/go/src/math/big/intconv.go:24
	}
//line /usr/local/go/src/math/big/intconv.go:24
	// _ = "end of CoverTab[5552]"
//line /usr/local/go/src/math/big/intconv.go:24
	_go_fuzz_dep_.CoverTab[5553]++
							return string(x.abs.itoa(x.neg, base))
//line /usr/local/go/src/math/big/intconv.go:25
	// _ = "end of CoverTab[5553]"
}

// Append appends the string representation of x, as generated by
//line /usr/local/go/src/math/big/intconv.go:28
// x.Text(base), to buf and returns the extended buffer.
//line /usr/local/go/src/math/big/intconv.go:30
func (x *Int) Append(buf []byte, base int) []byte {
//line /usr/local/go/src/math/big/intconv.go:30
	_go_fuzz_dep_.CoverTab[5556]++
							if x == nil {
//line /usr/local/go/src/math/big/intconv.go:31
		_go_fuzz_dep_.CoverTab[5558]++
								return append(buf, "<nil>"...)
//line /usr/local/go/src/math/big/intconv.go:32
		// _ = "end of CoverTab[5558]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:33
		_go_fuzz_dep_.CoverTab[5559]++
//line /usr/local/go/src/math/big/intconv.go:33
		// _ = "end of CoverTab[5559]"
//line /usr/local/go/src/math/big/intconv.go:33
	}
//line /usr/local/go/src/math/big/intconv.go:33
	// _ = "end of CoverTab[5556]"
//line /usr/local/go/src/math/big/intconv.go:33
	_go_fuzz_dep_.CoverTab[5557]++
							return append(buf, x.abs.itoa(x.neg, base)...)
//line /usr/local/go/src/math/big/intconv.go:34
	// _ = "end of CoverTab[5557]"
}

// String returns the decimal representation of x as generated by
//line /usr/local/go/src/math/big/intconv.go:37
// x.Text(10).
//line /usr/local/go/src/math/big/intconv.go:39
func (x *Int) String() string {
//line /usr/local/go/src/math/big/intconv.go:39
	_go_fuzz_dep_.CoverTab[5560]++
							return x.Text(10)
//line /usr/local/go/src/math/big/intconv.go:40
	// _ = "end of CoverTab[5560]"
}

// write count copies of text to s.
func writeMultiple(s fmt.State, text string, count int) {
//line /usr/local/go/src/math/big/intconv.go:44
	_go_fuzz_dep_.CoverTab[5561]++
							if len(text) > 0 {
//line /usr/local/go/src/math/big/intconv.go:45
		_go_fuzz_dep_.CoverTab[5562]++
								b := []byte(text)
								for ; count > 0; count-- {
//line /usr/local/go/src/math/big/intconv.go:47
			_go_fuzz_dep_.CoverTab[5563]++
									s.Write(b)
//line /usr/local/go/src/math/big/intconv.go:48
			// _ = "end of CoverTab[5563]"
		}
//line /usr/local/go/src/math/big/intconv.go:49
		// _ = "end of CoverTab[5562]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:50
		_go_fuzz_dep_.CoverTab[5564]++
//line /usr/local/go/src/math/big/intconv.go:50
		// _ = "end of CoverTab[5564]"
//line /usr/local/go/src/math/big/intconv.go:50
	}
//line /usr/local/go/src/math/big/intconv.go:50
	// _ = "end of CoverTab[5561]"
}

var _ fmt.Formatter = intOne	// *Int must implement fmt.Formatter

// Format implements fmt.Formatter. It accepts the formats
//line /usr/local/go/src/math/big/intconv.go:55
// 'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix),
//line /usr/local/go/src/math/big/intconv.go:55
// 'd' (decimal), 'x' (lowercase hexadecimal), and
//line /usr/local/go/src/math/big/intconv.go:55
// 'X' (uppercase hexadecimal).
//line /usr/local/go/src/math/big/intconv.go:55
// Also supported are the full suite of package fmt's format
//line /usr/local/go/src/math/big/intconv.go:55
// flags for integral types, including '+' and ' ' for sign
//line /usr/local/go/src/math/big/intconv.go:55
// control, '#' for leading zero in octal and for hexadecimal,
//line /usr/local/go/src/math/big/intconv.go:55
// a leading "0x" or "0X" for "%#x" and "%#X" respectively,
//line /usr/local/go/src/math/big/intconv.go:55
// specification of minimum digits precision, output field
//line /usr/local/go/src/math/big/intconv.go:55
// width, space or zero padding, and '-' for left or right
//line /usr/local/go/src/math/big/intconv.go:55
// justification.
//line /usr/local/go/src/math/big/intconv.go:66
func (x *Int) Format(s fmt.State, ch rune) {
//line /usr/local/go/src/math/big/intconv.go:66
	_go_fuzz_dep_.CoverTab[5565]++
	// determine base
	var base int
	switch ch {
	case 'b':
//line /usr/local/go/src/math/big/intconv.go:70
		_go_fuzz_dep_.CoverTab[5574]++
								base = 2
//line /usr/local/go/src/math/big/intconv.go:71
		// _ = "end of CoverTab[5574]"
	case 'o', 'O':
//line /usr/local/go/src/math/big/intconv.go:72
		_go_fuzz_dep_.CoverTab[5575]++
								base = 8
//line /usr/local/go/src/math/big/intconv.go:73
		// _ = "end of CoverTab[5575]"
	case 'd', 's', 'v':
//line /usr/local/go/src/math/big/intconv.go:74
		_go_fuzz_dep_.CoverTab[5576]++
								base = 10
//line /usr/local/go/src/math/big/intconv.go:75
		// _ = "end of CoverTab[5576]"
	case 'x', 'X':
//line /usr/local/go/src/math/big/intconv.go:76
		_go_fuzz_dep_.CoverTab[5577]++
								base = 16
//line /usr/local/go/src/math/big/intconv.go:77
		// _ = "end of CoverTab[5577]"
	default:
//line /usr/local/go/src/math/big/intconv.go:78
		_go_fuzz_dep_.CoverTab[5578]++

								fmt.Fprintf(s, "%%!%c(big.Int=%s)", ch, x.String())
								return
//line /usr/local/go/src/math/big/intconv.go:81
		// _ = "end of CoverTab[5578]"
	}
//line /usr/local/go/src/math/big/intconv.go:82
	// _ = "end of CoverTab[5565]"
//line /usr/local/go/src/math/big/intconv.go:82
	_go_fuzz_dep_.CoverTab[5566]++

							if x == nil {
//line /usr/local/go/src/math/big/intconv.go:84
		_go_fuzz_dep_.CoverTab[5579]++
								fmt.Fprint(s, "<nil>")
								return
//line /usr/local/go/src/math/big/intconv.go:86
		// _ = "end of CoverTab[5579]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:87
		_go_fuzz_dep_.CoverTab[5580]++
//line /usr/local/go/src/math/big/intconv.go:87
		// _ = "end of CoverTab[5580]"
//line /usr/local/go/src/math/big/intconv.go:87
	}
//line /usr/local/go/src/math/big/intconv.go:87
	// _ = "end of CoverTab[5566]"
//line /usr/local/go/src/math/big/intconv.go:87
	_go_fuzz_dep_.CoverTab[5567]++

//line /usr/local/go/src/math/big/intconv.go:90
	sign := ""
	switch {
	case x.neg:
//line /usr/local/go/src/math/big/intconv.go:92
		_go_fuzz_dep_.CoverTab[5581]++
								sign = "-"
//line /usr/local/go/src/math/big/intconv.go:93
		// _ = "end of CoverTab[5581]"
	case s.Flag('+'):
//line /usr/local/go/src/math/big/intconv.go:94
		_go_fuzz_dep_.CoverTab[5582]++
								sign = "+"
//line /usr/local/go/src/math/big/intconv.go:95
		// _ = "end of CoverTab[5582]"
	case s.Flag(' '):
//line /usr/local/go/src/math/big/intconv.go:96
		_go_fuzz_dep_.CoverTab[5583]++
								sign = " "
//line /usr/local/go/src/math/big/intconv.go:97
		// _ = "end of CoverTab[5583]"
//line /usr/local/go/src/math/big/intconv.go:97
	default:
//line /usr/local/go/src/math/big/intconv.go:97
		_go_fuzz_dep_.CoverTab[5584]++
//line /usr/local/go/src/math/big/intconv.go:97
		// _ = "end of CoverTab[5584]"
	}
//line /usr/local/go/src/math/big/intconv.go:98
	// _ = "end of CoverTab[5567]"
//line /usr/local/go/src/math/big/intconv.go:98
	_go_fuzz_dep_.CoverTab[5568]++

//line /usr/local/go/src/math/big/intconv.go:101
	prefix := ""
	if s.Flag('#') {
//line /usr/local/go/src/math/big/intconv.go:102
		_go_fuzz_dep_.CoverTab[5585]++
								switch ch {
		case 'b':
//line /usr/local/go/src/math/big/intconv.go:104
			_go_fuzz_dep_.CoverTab[5586]++
									prefix = "0b"
//line /usr/local/go/src/math/big/intconv.go:105
			// _ = "end of CoverTab[5586]"
		case 'o':
//line /usr/local/go/src/math/big/intconv.go:106
			_go_fuzz_dep_.CoverTab[5587]++
									prefix = "0"
//line /usr/local/go/src/math/big/intconv.go:107
			// _ = "end of CoverTab[5587]"
		case 'x':
//line /usr/local/go/src/math/big/intconv.go:108
			_go_fuzz_dep_.CoverTab[5588]++
									prefix = "0x"
//line /usr/local/go/src/math/big/intconv.go:109
			// _ = "end of CoverTab[5588]"
		case 'X':
//line /usr/local/go/src/math/big/intconv.go:110
			_go_fuzz_dep_.CoverTab[5589]++
									prefix = "0X"
//line /usr/local/go/src/math/big/intconv.go:111
			// _ = "end of CoverTab[5589]"
//line /usr/local/go/src/math/big/intconv.go:111
		default:
//line /usr/local/go/src/math/big/intconv.go:111
			_go_fuzz_dep_.CoverTab[5590]++
//line /usr/local/go/src/math/big/intconv.go:111
			// _ = "end of CoverTab[5590]"
		}
//line /usr/local/go/src/math/big/intconv.go:112
		// _ = "end of CoverTab[5585]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:113
		_go_fuzz_dep_.CoverTab[5591]++
//line /usr/local/go/src/math/big/intconv.go:113
		// _ = "end of CoverTab[5591]"
//line /usr/local/go/src/math/big/intconv.go:113
	}
//line /usr/local/go/src/math/big/intconv.go:113
	// _ = "end of CoverTab[5568]"
//line /usr/local/go/src/math/big/intconv.go:113
	_go_fuzz_dep_.CoverTab[5569]++
							if ch == 'O' {
//line /usr/local/go/src/math/big/intconv.go:114
		_go_fuzz_dep_.CoverTab[5592]++
								prefix = "0o"
//line /usr/local/go/src/math/big/intconv.go:115
		// _ = "end of CoverTab[5592]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:116
		_go_fuzz_dep_.CoverTab[5593]++
//line /usr/local/go/src/math/big/intconv.go:116
		// _ = "end of CoverTab[5593]"
//line /usr/local/go/src/math/big/intconv.go:116
	}
//line /usr/local/go/src/math/big/intconv.go:116
	// _ = "end of CoverTab[5569]"
//line /usr/local/go/src/math/big/intconv.go:116
	_go_fuzz_dep_.CoverTab[5570]++

							digits := x.abs.utoa(base)
							if ch == 'X' {
//line /usr/local/go/src/math/big/intconv.go:119
		_go_fuzz_dep_.CoverTab[5594]++

								for i, d := range digits {
//line /usr/local/go/src/math/big/intconv.go:121
			_go_fuzz_dep_.CoverTab[5595]++
									if 'a' <= d && func() bool {
//line /usr/local/go/src/math/big/intconv.go:122
				_go_fuzz_dep_.CoverTab[5596]++
//line /usr/local/go/src/math/big/intconv.go:122
				return d <= 'z'
//line /usr/local/go/src/math/big/intconv.go:122
				// _ = "end of CoverTab[5596]"
//line /usr/local/go/src/math/big/intconv.go:122
			}() {
//line /usr/local/go/src/math/big/intconv.go:122
				_go_fuzz_dep_.CoverTab[5597]++
										digits[i] = 'A' + (d - 'a')
//line /usr/local/go/src/math/big/intconv.go:123
				// _ = "end of CoverTab[5597]"
			} else {
//line /usr/local/go/src/math/big/intconv.go:124
				_go_fuzz_dep_.CoverTab[5598]++
//line /usr/local/go/src/math/big/intconv.go:124
				// _ = "end of CoverTab[5598]"
//line /usr/local/go/src/math/big/intconv.go:124
			}
//line /usr/local/go/src/math/big/intconv.go:124
			// _ = "end of CoverTab[5595]"
		}
//line /usr/local/go/src/math/big/intconv.go:125
		// _ = "end of CoverTab[5594]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:126
		_go_fuzz_dep_.CoverTab[5599]++
//line /usr/local/go/src/math/big/intconv.go:126
		// _ = "end of CoverTab[5599]"
//line /usr/local/go/src/math/big/intconv.go:126
	}
//line /usr/local/go/src/math/big/intconv.go:126
	// _ = "end of CoverTab[5570]"
//line /usr/local/go/src/math/big/intconv.go:126
	_go_fuzz_dep_.CoverTab[5571]++

							// number of characters for the three classes of number padding
							var left int	// space characters to left of digits for right justification ("%8d")
							var zeros int	// zero characters (actually cs[0]) as left-most digits ("%.8d")
							var right int	// space characters to right of digits for left justification ("%-8d")

//line /usr/local/go/src/math/big/intconv.go:134
	precision, precisionSet := s.Precision()
	if precisionSet {
//line /usr/local/go/src/math/big/intconv.go:135
		_go_fuzz_dep_.CoverTab[5600]++
								switch {
		case len(digits) < precision:
//line /usr/local/go/src/math/big/intconv.go:137
			_go_fuzz_dep_.CoverTab[5601]++
									zeros = precision - len(digits)
//line /usr/local/go/src/math/big/intconv.go:138
			// _ = "end of CoverTab[5601]"
		case len(digits) == 1 && func() bool {
//line /usr/local/go/src/math/big/intconv.go:139
			_go_fuzz_dep_.CoverTab[5604]++
//line /usr/local/go/src/math/big/intconv.go:139
			return digits[0] == '0'
//line /usr/local/go/src/math/big/intconv.go:139
			// _ = "end of CoverTab[5604]"
//line /usr/local/go/src/math/big/intconv.go:139
		}() && func() bool {
//line /usr/local/go/src/math/big/intconv.go:139
			_go_fuzz_dep_.CoverTab[5605]++
//line /usr/local/go/src/math/big/intconv.go:139
			return precision == 0
//line /usr/local/go/src/math/big/intconv.go:139
			// _ = "end of CoverTab[5605]"
//line /usr/local/go/src/math/big/intconv.go:139
		}():
//line /usr/local/go/src/math/big/intconv.go:139
			_go_fuzz_dep_.CoverTab[5602]++
									return
//line /usr/local/go/src/math/big/intconv.go:140
			// _ = "end of CoverTab[5602]"
//line /usr/local/go/src/math/big/intconv.go:140
		default:
//line /usr/local/go/src/math/big/intconv.go:140
			_go_fuzz_dep_.CoverTab[5603]++
//line /usr/local/go/src/math/big/intconv.go:140
			// _ = "end of CoverTab[5603]"
		}
//line /usr/local/go/src/math/big/intconv.go:141
		// _ = "end of CoverTab[5600]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:142
		_go_fuzz_dep_.CoverTab[5606]++
//line /usr/local/go/src/math/big/intconv.go:142
		// _ = "end of CoverTab[5606]"
//line /usr/local/go/src/math/big/intconv.go:142
	}
//line /usr/local/go/src/math/big/intconv.go:142
	// _ = "end of CoverTab[5571]"
//line /usr/local/go/src/math/big/intconv.go:142
	_go_fuzz_dep_.CoverTab[5572]++

//line /usr/local/go/src/math/big/intconv.go:145
	length := len(sign) + len(prefix) + zeros + len(digits)
	if width, widthSet := s.Width(); widthSet && func() bool {
//line /usr/local/go/src/math/big/intconv.go:146
		_go_fuzz_dep_.CoverTab[5607]++
//line /usr/local/go/src/math/big/intconv.go:146
		return length < width
//line /usr/local/go/src/math/big/intconv.go:146
		// _ = "end of CoverTab[5607]"
//line /usr/local/go/src/math/big/intconv.go:146
	}() {
//line /usr/local/go/src/math/big/intconv.go:146
		_go_fuzz_dep_.CoverTab[5608]++
								switch d := width - length; {
		case s.Flag('-'):
//line /usr/local/go/src/math/big/intconv.go:148
			_go_fuzz_dep_.CoverTab[5609]++

									right = d
//line /usr/local/go/src/math/big/intconv.go:150
			// _ = "end of CoverTab[5609]"
		case s.Flag('0') && func() bool {
//line /usr/local/go/src/math/big/intconv.go:151
			_go_fuzz_dep_.CoverTab[5612]++
//line /usr/local/go/src/math/big/intconv.go:151
			return !precisionSet
//line /usr/local/go/src/math/big/intconv.go:151
			// _ = "end of CoverTab[5612]"
//line /usr/local/go/src/math/big/intconv.go:151
		}():
//line /usr/local/go/src/math/big/intconv.go:151
			_go_fuzz_dep_.CoverTab[5610]++

									zeros = d
//line /usr/local/go/src/math/big/intconv.go:153
			// _ = "end of CoverTab[5610]"
		default:
//line /usr/local/go/src/math/big/intconv.go:154
			_go_fuzz_dep_.CoverTab[5611]++

									left = d
//line /usr/local/go/src/math/big/intconv.go:156
			// _ = "end of CoverTab[5611]"
		}
//line /usr/local/go/src/math/big/intconv.go:157
		// _ = "end of CoverTab[5608]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:158
		_go_fuzz_dep_.CoverTab[5613]++
//line /usr/local/go/src/math/big/intconv.go:158
		// _ = "end of CoverTab[5613]"
//line /usr/local/go/src/math/big/intconv.go:158
	}
//line /usr/local/go/src/math/big/intconv.go:158
	// _ = "end of CoverTab[5572]"
//line /usr/local/go/src/math/big/intconv.go:158
	_go_fuzz_dep_.CoverTab[5573]++

//line /usr/local/go/src/math/big/intconv.go:161
	writeMultiple(s, " ", left)
							writeMultiple(s, sign, 1)
							writeMultiple(s, prefix, 1)
							writeMultiple(s, "0", zeros)
							s.Write(digits)
							writeMultiple(s, " ", right)
//line /usr/local/go/src/math/big/intconv.go:166
	// _ = "end of CoverTab[5573]"
}

// scan sets z to the integer value corresponding to the longest possible prefix
//line /usr/local/go/src/math/big/intconv.go:169
// read from r representing a signed integer number in a given conversion base.
//line /usr/local/go/src/math/big/intconv.go:169
// It returns z, the actual conversion base used, and an error, if any. In the
//line /usr/local/go/src/math/big/intconv.go:169
// error case, the value of z is undefined but the returned value is nil. The
//line /usr/local/go/src/math/big/intconv.go:169
// syntax follows the syntax of integer literals in Go.
//line /usr/local/go/src/math/big/intconv.go:169
//
//line /usr/local/go/src/math/big/intconv.go:169
// The base argument must be 0 or a value from 2 through MaxBase. If the base
//line /usr/local/go/src/math/big/intconv.go:169
// is 0, the string prefix determines the actual conversion base. A prefix of
//line /usr/local/go/src/math/big/intconv.go:169
// “0b” or “0B” selects base 2; a “0”, “0o”, or “0O” prefix selects
//line /usr/local/go/src/math/big/intconv.go:169
// base 8, and a “0x” or “0X” prefix selects base 16. Otherwise the selected
//line /usr/local/go/src/math/big/intconv.go:169
// base is 10.
//line /usr/local/go/src/math/big/intconv.go:180
func (z *Int) scan(r io.ByteScanner, base int) (*Int, int, error) {
//line /usr/local/go/src/math/big/intconv.go:180
	_go_fuzz_dep_.CoverTab[5614]++

							neg, err := scanSign(r)
							if err != nil {
//line /usr/local/go/src/math/big/intconv.go:183
		_go_fuzz_dep_.CoverTab[5617]++
								return nil, 0, err
//line /usr/local/go/src/math/big/intconv.go:184
		// _ = "end of CoverTab[5617]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:185
		_go_fuzz_dep_.CoverTab[5618]++
//line /usr/local/go/src/math/big/intconv.go:185
		// _ = "end of CoverTab[5618]"
//line /usr/local/go/src/math/big/intconv.go:185
	}
//line /usr/local/go/src/math/big/intconv.go:185
	// _ = "end of CoverTab[5614]"
//line /usr/local/go/src/math/big/intconv.go:185
	_go_fuzz_dep_.CoverTab[5615]++

//line /usr/local/go/src/math/big/intconv.go:188
	z.abs, base, _, err = z.abs.scan(r, base, false)
	if err != nil {
//line /usr/local/go/src/math/big/intconv.go:189
		_go_fuzz_dep_.CoverTab[5619]++
								return nil, base, err
//line /usr/local/go/src/math/big/intconv.go:190
		// _ = "end of CoverTab[5619]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:191
		_go_fuzz_dep_.CoverTab[5620]++
//line /usr/local/go/src/math/big/intconv.go:191
		// _ = "end of CoverTab[5620]"
//line /usr/local/go/src/math/big/intconv.go:191
	}
//line /usr/local/go/src/math/big/intconv.go:191
	// _ = "end of CoverTab[5615]"
//line /usr/local/go/src/math/big/intconv.go:191
	_go_fuzz_dep_.CoverTab[5616]++
							z.neg = len(z.abs) > 0 && func() bool {
//line /usr/local/go/src/math/big/intconv.go:192
		_go_fuzz_dep_.CoverTab[5621]++
//line /usr/local/go/src/math/big/intconv.go:192
		return neg
//line /usr/local/go/src/math/big/intconv.go:192
		// _ = "end of CoverTab[5621]"
//line /usr/local/go/src/math/big/intconv.go:192
	}()

							return z, base, nil
//line /usr/local/go/src/math/big/intconv.go:194
	// _ = "end of CoverTab[5616]"
}

func scanSign(r io.ByteScanner) (neg bool, err error) {
//line /usr/local/go/src/math/big/intconv.go:197
	_go_fuzz_dep_.CoverTab[5622]++
							var ch byte
							if ch, err = r.ReadByte(); err != nil {
//line /usr/local/go/src/math/big/intconv.go:199
		_go_fuzz_dep_.CoverTab[5625]++
								return false, err
//line /usr/local/go/src/math/big/intconv.go:200
		// _ = "end of CoverTab[5625]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:201
		_go_fuzz_dep_.CoverTab[5626]++
//line /usr/local/go/src/math/big/intconv.go:201
		// _ = "end of CoverTab[5626]"
//line /usr/local/go/src/math/big/intconv.go:201
	}
//line /usr/local/go/src/math/big/intconv.go:201
	// _ = "end of CoverTab[5622]"
//line /usr/local/go/src/math/big/intconv.go:201
	_go_fuzz_dep_.CoverTab[5623]++
							switch ch {
	case '-':
//line /usr/local/go/src/math/big/intconv.go:203
		_go_fuzz_dep_.CoverTab[5627]++
								neg = true
//line /usr/local/go/src/math/big/intconv.go:204
		// _ = "end of CoverTab[5627]"
	case '+':
//line /usr/local/go/src/math/big/intconv.go:205
		_go_fuzz_dep_.CoverTab[5628]++
//line /usr/local/go/src/math/big/intconv.go:205
		// _ = "end of CoverTab[5628]"

	default:
//line /usr/local/go/src/math/big/intconv.go:207
		_go_fuzz_dep_.CoverTab[5629]++
								r.UnreadByte()
//line /usr/local/go/src/math/big/intconv.go:208
		// _ = "end of CoverTab[5629]"
	}
//line /usr/local/go/src/math/big/intconv.go:209
	// _ = "end of CoverTab[5623]"
//line /usr/local/go/src/math/big/intconv.go:209
	_go_fuzz_dep_.CoverTab[5624]++
							return
//line /usr/local/go/src/math/big/intconv.go:210
	// _ = "end of CoverTab[5624]"
}

// byteReader is a local wrapper around fmt.ScanState;
//line /usr/local/go/src/math/big/intconv.go:213
// it implements the ByteReader interface.
//line /usr/local/go/src/math/big/intconv.go:215
type byteReader struct {
	fmt.ScanState
}

func (r byteReader) ReadByte() (byte, error) {
//line /usr/local/go/src/math/big/intconv.go:219
	_go_fuzz_dep_.CoverTab[5630]++
							ch, size, err := r.ReadRune()
							if size != 1 && func() bool {
//line /usr/local/go/src/math/big/intconv.go:221
		_go_fuzz_dep_.CoverTab[5632]++
//line /usr/local/go/src/math/big/intconv.go:221
		return err == nil
//line /usr/local/go/src/math/big/intconv.go:221
		// _ = "end of CoverTab[5632]"
//line /usr/local/go/src/math/big/intconv.go:221
	}() {
//line /usr/local/go/src/math/big/intconv.go:221
		_go_fuzz_dep_.CoverTab[5633]++
								err = fmt.Errorf("invalid rune %#U", ch)
//line /usr/local/go/src/math/big/intconv.go:222
		// _ = "end of CoverTab[5633]"
	} else {
//line /usr/local/go/src/math/big/intconv.go:223
		_go_fuzz_dep_.CoverTab[5634]++
//line /usr/local/go/src/math/big/intconv.go:223
		// _ = "end of CoverTab[5634]"
//line /usr/local/go/src/math/big/intconv.go:223
	}
//line /usr/local/go/src/math/big/intconv.go:223
	// _ = "end of CoverTab[5630]"
//line /usr/local/go/src/math/big/intconv.go:223
	_go_fuzz_dep_.CoverTab[5631]++
							return byte(ch), err
//line /usr/local/go/src/math/big/intconv.go:224
	// _ = "end of CoverTab[5631]"
}

func (r byteReader) UnreadByte() error {
//line /usr/local/go/src/math/big/intconv.go:227
	_go_fuzz_dep_.CoverTab[5635]++
							return r.UnreadRune()
//line /usr/local/go/src/math/big/intconv.go:228
	// _ = "end of CoverTab[5635]"
}

var _ fmt.Scanner = intOne	// *Int must implement fmt.Scanner

// Scan is a support routine for fmt.Scanner; it sets z to the value of
//line /usr/local/go/src/math/big/intconv.go:233
// the scanned number. It accepts the formats 'b' (binary), 'o' (octal),
//line /usr/local/go/src/math/big/intconv.go:233
// 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).
//line /usr/local/go/src/math/big/intconv.go:236
func (z *Int) Scan(s fmt.ScanState, ch rune) error {
//line /usr/local/go/src/math/big/intconv.go:236
	_go_fuzz_dep_.CoverTab[5636]++
							s.SkipSpace()
							base := 0
							switch ch {
	case 'b':
//line /usr/local/go/src/math/big/intconv.go:240
		_go_fuzz_dep_.CoverTab[5638]++
								base = 2
//line /usr/local/go/src/math/big/intconv.go:241
		// _ = "end of CoverTab[5638]"
	case 'o':
//line /usr/local/go/src/math/big/intconv.go:242
		_go_fuzz_dep_.CoverTab[5639]++
								base = 8
//line /usr/local/go/src/math/big/intconv.go:243
		// _ = "end of CoverTab[5639]"
	case 'd':
//line /usr/local/go/src/math/big/intconv.go:244
		_go_fuzz_dep_.CoverTab[5640]++
								base = 10
//line /usr/local/go/src/math/big/intconv.go:245
		// _ = "end of CoverTab[5640]"
	case 'x', 'X':
//line /usr/local/go/src/math/big/intconv.go:246
		_go_fuzz_dep_.CoverTab[5641]++
								base = 16
//line /usr/local/go/src/math/big/intconv.go:247
		// _ = "end of CoverTab[5641]"
	case 's', 'v':
//line /usr/local/go/src/math/big/intconv.go:248
		_go_fuzz_dep_.CoverTab[5642]++
//line /usr/local/go/src/math/big/intconv.go:248
		// _ = "end of CoverTab[5642]"

	default:
//line /usr/local/go/src/math/big/intconv.go:250
		_go_fuzz_dep_.CoverTab[5643]++
								return errors.New("Int.Scan: invalid verb")
//line /usr/local/go/src/math/big/intconv.go:251
		// _ = "end of CoverTab[5643]"
	}
//line /usr/local/go/src/math/big/intconv.go:252
	// _ = "end of CoverTab[5636]"
//line /usr/local/go/src/math/big/intconv.go:252
	_go_fuzz_dep_.CoverTab[5637]++
							_, _, err := z.scan(byteReader{s}, base)
							return err
//line /usr/local/go/src/math/big/intconv.go:254
	// _ = "end of CoverTab[5637]"
}

//line /usr/local/go/src/math/big/intconv.go:255
var _ = _atomic_.LoadUint32(&_go_fuzz_dep_.NoUse)
//line /usr/local/go/src/math/big/intconv.go:255
var _ = _go_fuzz_dep_.CoverTab
