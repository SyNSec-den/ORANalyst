// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

//line /usr/local/go/src/mime/multipart/multipart.go:6
/*
Package multipart implements MIME multipart parsing, as defined in RFC
2046.

The implementation is sufficient for HTTP (RFC 2388) and the multipart
bodies generated by popular browsers.

# Limits

To protect against malicious inputs, this package sets limits on the size
of the MIME data it processes.

Reader.NextPart and Reader.NextRawPart limit the number of headers in a
part to 10000 and Reader.ReadForm limits the total number of headers in all
FileHeaders to 10000.
These limits may be adjusted with the GODEBUG=multipartmaxheaders=<values>
setting.

Reader.ReadForm further limits the number of parts in a form to 1000.
This limit may be adjusted with the GODEBUG=multipartmaxparts=<value>
setting.
*/
package multipart

//line /usr/local/go/src/mime/multipart/multipart.go:28
import (
//line /usr/local/go/src/mime/multipart/multipart.go:28
	_go_fuzz_dep_ "go-fuzz-dep"
//line /usr/local/go/src/mime/multipart/multipart.go:28
)
//line /usr/local/go/src/mime/multipart/multipart.go:28
import (
//line /usr/local/go/src/mime/multipart/multipart.go:28
	_atomic_ "sync/atomic"
//line /usr/local/go/src/mime/multipart/multipart.go:28
)

import (
	"bufio"
	"bytes"
	"fmt"
	"internal/godebug"
	"io"
	"mime"
	"mime/quotedprintable"
	"net/textproto"
	"path/filepath"
	"strconv"
	"strings"
)

var emptyParams = make(map[string]string)

// This constant needs to be at least 76 for this package to work correctly.
//line /usr/local/go/src/mime/multipart/multipart.go:46
// This is because \r\n--separator_of_len_70- would fill the buffer and it
//line /usr/local/go/src/mime/multipart/multipart.go:46
// wouldn't be safe to consume a single byte from it.
//line /usr/local/go/src/mime/multipart/multipart.go:49
const peekBufferSize = 4096

// A Part represents a single part in a multipart body.
type Part struct {
	// The headers of the body, if any, with the keys canonicalized
	// in the same fashion that the Go http.Request headers are.
	// For example, "foo-bar" changes case to "Foo-Bar"
	Header	textproto.MIMEHeader

	mr	*Reader

	disposition		string
	dispositionParams	map[string]string

	// r is either a reader directly reading from mr, or it's a
	// wrapper around such a reader, decoding the
	// Content-Transfer-Encoding
	r	io.Reader

	n	int	// known data bytes waiting in mr.bufReader
	total	int64	// total data bytes read already
	err	error	// error to return when n == 0
	readErr	error	// read error observed from mr.bufReader
}

// FormName returns the name parameter if p has a Content-Disposition
//line /usr/local/go/src/mime/multipart/multipart.go:74
// of type "form-data".  Otherwise it returns the empty string.
//line /usr/local/go/src/mime/multipart/multipart.go:76
func (p *Part) FormName() string {
//line /usr/local/go/src/mime/multipart/multipart.go:76
	_go_fuzz_dep_.CoverTab[36174]++

//line /usr/local/go/src/mime/multipart/multipart.go:79
	if p.dispositionParams == nil {
//line /usr/local/go/src/mime/multipart/multipart.go:79
		_go_fuzz_dep_.CoverTab[36177]++
									p.parseContentDisposition()
//line /usr/local/go/src/mime/multipart/multipart.go:80
		// _ = "end of CoverTab[36177]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:81
		_go_fuzz_dep_.CoverTab[36178]++
//line /usr/local/go/src/mime/multipart/multipart.go:81
		// _ = "end of CoverTab[36178]"
//line /usr/local/go/src/mime/multipart/multipart.go:81
	}
//line /usr/local/go/src/mime/multipart/multipart.go:81
	// _ = "end of CoverTab[36174]"
//line /usr/local/go/src/mime/multipart/multipart.go:81
	_go_fuzz_dep_.CoverTab[36175]++
								if p.disposition != "form-data" {
//line /usr/local/go/src/mime/multipart/multipart.go:82
		_go_fuzz_dep_.CoverTab[36179]++
									return ""
//line /usr/local/go/src/mime/multipart/multipart.go:83
		// _ = "end of CoverTab[36179]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:84
		_go_fuzz_dep_.CoverTab[36180]++
//line /usr/local/go/src/mime/multipart/multipart.go:84
		// _ = "end of CoverTab[36180]"
//line /usr/local/go/src/mime/multipart/multipart.go:84
	}
//line /usr/local/go/src/mime/multipart/multipart.go:84
	// _ = "end of CoverTab[36175]"
//line /usr/local/go/src/mime/multipart/multipart.go:84
	_go_fuzz_dep_.CoverTab[36176]++
								return p.dispositionParams["name"]
//line /usr/local/go/src/mime/multipart/multipart.go:85
	// _ = "end of CoverTab[36176]"
}

// FileName returns the filename parameter of the Part's Content-Disposition
//line /usr/local/go/src/mime/multipart/multipart.go:88
// header. If not empty, the filename is passed through filepath.Base (which is
//line /usr/local/go/src/mime/multipart/multipart.go:88
// platform dependent) before being returned.
//line /usr/local/go/src/mime/multipart/multipart.go:91
func (p *Part) FileName() string {
//line /usr/local/go/src/mime/multipart/multipart.go:91
	_go_fuzz_dep_.CoverTab[36181]++
								if p.dispositionParams == nil {
//line /usr/local/go/src/mime/multipart/multipart.go:92
		_go_fuzz_dep_.CoverTab[36184]++
									p.parseContentDisposition()
//line /usr/local/go/src/mime/multipart/multipart.go:93
		// _ = "end of CoverTab[36184]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:94
		_go_fuzz_dep_.CoverTab[36185]++
//line /usr/local/go/src/mime/multipart/multipart.go:94
		// _ = "end of CoverTab[36185]"
//line /usr/local/go/src/mime/multipart/multipart.go:94
	}
//line /usr/local/go/src/mime/multipart/multipart.go:94
	// _ = "end of CoverTab[36181]"
//line /usr/local/go/src/mime/multipart/multipart.go:94
	_go_fuzz_dep_.CoverTab[36182]++
								filename := p.dispositionParams["filename"]
								if filename == "" {
//line /usr/local/go/src/mime/multipart/multipart.go:96
		_go_fuzz_dep_.CoverTab[36186]++
									return ""
//line /usr/local/go/src/mime/multipart/multipart.go:97
		// _ = "end of CoverTab[36186]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:98
		_go_fuzz_dep_.CoverTab[36187]++
//line /usr/local/go/src/mime/multipart/multipart.go:98
		// _ = "end of CoverTab[36187]"
//line /usr/local/go/src/mime/multipart/multipart.go:98
	}
//line /usr/local/go/src/mime/multipart/multipart.go:98
	// _ = "end of CoverTab[36182]"
//line /usr/local/go/src/mime/multipart/multipart.go:98
	_go_fuzz_dep_.CoverTab[36183]++

//line /usr/local/go/src/mime/multipart/multipart.go:101
	return filepath.Base(filename)
//line /usr/local/go/src/mime/multipart/multipart.go:101
	// _ = "end of CoverTab[36183]"
}

func (p *Part) parseContentDisposition() {
//line /usr/local/go/src/mime/multipart/multipart.go:104
	_go_fuzz_dep_.CoverTab[36188]++
								v := p.Header.Get("Content-Disposition")
								var err error
								p.disposition, p.dispositionParams, err = mime.ParseMediaType(v)
								if err != nil {
//line /usr/local/go/src/mime/multipart/multipart.go:108
		_go_fuzz_dep_.CoverTab[36189]++
									p.dispositionParams = emptyParams
//line /usr/local/go/src/mime/multipart/multipart.go:109
		// _ = "end of CoverTab[36189]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:110
		_go_fuzz_dep_.CoverTab[36190]++
//line /usr/local/go/src/mime/multipart/multipart.go:110
		// _ = "end of CoverTab[36190]"
//line /usr/local/go/src/mime/multipart/multipart.go:110
	}
//line /usr/local/go/src/mime/multipart/multipart.go:110
	// _ = "end of CoverTab[36188]"
}

// NewReader creates a new multipart Reader reading from r using the
//line /usr/local/go/src/mime/multipart/multipart.go:113
// given MIME boundary.
//line /usr/local/go/src/mime/multipart/multipart.go:113
//
//line /usr/local/go/src/mime/multipart/multipart.go:113
// The boundary is usually obtained from the "boundary" parameter of
//line /usr/local/go/src/mime/multipart/multipart.go:113
// the message's "Content-Type" header. Use mime.ParseMediaType to
//line /usr/local/go/src/mime/multipart/multipart.go:113
// parse such headers.
//line /usr/local/go/src/mime/multipart/multipart.go:119
func NewReader(r io.Reader, boundary string) *Reader {
//line /usr/local/go/src/mime/multipart/multipart.go:119
	_go_fuzz_dep_.CoverTab[36191]++
								b := []byte("\r\n--" + boundary + "--")
								return &Reader{
		bufReader:		bufio.NewReaderSize(&stickyErrorReader{r: r}, peekBufferSize),
		nl:			b[:2],
		nlDashBoundary:		b[:len(b)-2],
		dashBoundaryDash:	b[2:],
		dashBoundary:		b[2 : len(b)-2],
	}
//line /usr/local/go/src/mime/multipart/multipart.go:127
	// _ = "end of CoverTab[36191]"
}

// stickyErrorReader is an io.Reader which never calls Read on its
//line /usr/local/go/src/mime/multipart/multipart.go:130
// underlying Reader once an error has been seen. (the io.Reader
//line /usr/local/go/src/mime/multipart/multipart.go:130
// interface's contract promises nothing about the return values of
//line /usr/local/go/src/mime/multipart/multipart.go:130
// Read calls after an error, yet this package does do multiple Reads
//line /usr/local/go/src/mime/multipart/multipart.go:130
// after error)
//line /usr/local/go/src/mime/multipart/multipart.go:135
type stickyErrorReader struct {
	r	io.Reader
	err	error
}

func (r *stickyErrorReader) Read(p []byte) (n int, _ error) {
//line /usr/local/go/src/mime/multipart/multipart.go:140
	_go_fuzz_dep_.CoverTab[36192]++
								if r.err != nil {
//line /usr/local/go/src/mime/multipart/multipart.go:141
		_go_fuzz_dep_.CoverTab[36194]++
									return 0, r.err
//line /usr/local/go/src/mime/multipart/multipart.go:142
		// _ = "end of CoverTab[36194]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:143
		_go_fuzz_dep_.CoverTab[36195]++
//line /usr/local/go/src/mime/multipart/multipart.go:143
		// _ = "end of CoverTab[36195]"
//line /usr/local/go/src/mime/multipart/multipart.go:143
	}
//line /usr/local/go/src/mime/multipart/multipart.go:143
	// _ = "end of CoverTab[36192]"
//line /usr/local/go/src/mime/multipart/multipart.go:143
	_go_fuzz_dep_.CoverTab[36193]++
								n, r.err = r.r.Read(p)
								return n, r.err
//line /usr/local/go/src/mime/multipart/multipart.go:145
	// _ = "end of CoverTab[36193]"
}

func newPart(mr *Reader, rawPart bool, maxMIMEHeaderSize, maxMIMEHeaders int64) (*Part, error) {
//line /usr/local/go/src/mime/multipart/multipart.go:148
	_go_fuzz_dep_.CoverTab[36196]++
								bp := &Part{
		Header:	make(map[string][]string),
		mr:	mr,
	}
	if err := bp.populateHeaders(maxMIMEHeaderSize, maxMIMEHeaders); err != nil {
//line /usr/local/go/src/mime/multipart/multipart.go:153
		_go_fuzz_dep_.CoverTab[36199]++
									return nil, err
//line /usr/local/go/src/mime/multipart/multipart.go:154
		// _ = "end of CoverTab[36199]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:155
		_go_fuzz_dep_.CoverTab[36200]++
//line /usr/local/go/src/mime/multipart/multipart.go:155
		// _ = "end of CoverTab[36200]"
//line /usr/local/go/src/mime/multipart/multipart.go:155
	}
//line /usr/local/go/src/mime/multipart/multipart.go:155
	// _ = "end of CoverTab[36196]"
//line /usr/local/go/src/mime/multipart/multipart.go:155
	_go_fuzz_dep_.CoverTab[36197]++
								bp.r = partReader{bp}

//line /usr/local/go/src/mime/multipart/multipart.go:159
	if !rawPart {
//line /usr/local/go/src/mime/multipart/multipart.go:159
		_go_fuzz_dep_.CoverTab[36201]++
									const cte = "Content-Transfer-Encoding"
									if strings.EqualFold(bp.Header.Get(cte), "quoted-printable") {
//line /usr/local/go/src/mime/multipart/multipart.go:161
			_go_fuzz_dep_.CoverTab[36202]++
										bp.Header.Del(cte)
										bp.r = quotedprintable.NewReader(bp.r)
//line /usr/local/go/src/mime/multipart/multipart.go:163
			// _ = "end of CoverTab[36202]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:164
			_go_fuzz_dep_.CoverTab[36203]++
//line /usr/local/go/src/mime/multipart/multipart.go:164
			// _ = "end of CoverTab[36203]"
//line /usr/local/go/src/mime/multipart/multipart.go:164
		}
//line /usr/local/go/src/mime/multipart/multipart.go:164
		// _ = "end of CoverTab[36201]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:165
		_go_fuzz_dep_.CoverTab[36204]++
//line /usr/local/go/src/mime/multipart/multipart.go:165
		// _ = "end of CoverTab[36204]"
//line /usr/local/go/src/mime/multipart/multipart.go:165
	}
//line /usr/local/go/src/mime/multipart/multipart.go:165
	// _ = "end of CoverTab[36197]"
//line /usr/local/go/src/mime/multipart/multipart.go:165
	_go_fuzz_dep_.CoverTab[36198]++
								return bp, nil
//line /usr/local/go/src/mime/multipart/multipart.go:166
	// _ = "end of CoverTab[36198]"
}

func (p *Part) populateHeaders(maxMIMEHeaderSize, maxMIMEHeaders int64) error {
//line /usr/local/go/src/mime/multipart/multipart.go:169
	_go_fuzz_dep_.CoverTab[36205]++
								r := textproto.NewReader(p.mr.bufReader)
								header, err := readMIMEHeader(r, maxMIMEHeaderSize, maxMIMEHeaders)
								if err == nil {
//line /usr/local/go/src/mime/multipart/multipart.go:172
		_go_fuzz_dep_.CoverTab[36208]++
									p.Header = header
//line /usr/local/go/src/mime/multipart/multipart.go:173
		// _ = "end of CoverTab[36208]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:174
		_go_fuzz_dep_.CoverTab[36209]++
//line /usr/local/go/src/mime/multipart/multipart.go:174
		// _ = "end of CoverTab[36209]"
//line /usr/local/go/src/mime/multipart/multipart.go:174
	}
//line /usr/local/go/src/mime/multipart/multipart.go:174
	// _ = "end of CoverTab[36205]"
//line /usr/local/go/src/mime/multipart/multipart.go:174
	_go_fuzz_dep_.CoverTab[36206]++

								if err != nil && func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:176
		_go_fuzz_dep_.CoverTab[36210]++
//line /usr/local/go/src/mime/multipart/multipart.go:176
		return err.Error() == "message too large"
//line /usr/local/go/src/mime/multipart/multipart.go:176
		// _ = "end of CoverTab[36210]"
//line /usr/local/go/src/mime/multipart/multipart.go:176
	}() {
//line /usr/local/go/src/mime/multipart/multipart.go:176
		_go_fuzz_dep_.CoverTab[36211]++
									err = ErrMessageTooLarge
//line /usr/local/go/src/mime/multipart/multipart.go:177
		// _ = "end of CoverTab[36211]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:178
		_go_fuzz_dep_.CoverTab[36212]++
//line /usr/local/go/src/mime/multipart/multipart.go:178
		// _ = "end of CoverTab[36212]"
//line /usr/local/go/src/mime/multipart/multipart.go:178
	}
//line /usr/local/go/src/mime/multipart/multipart.go:178
	// _ = "end of CoverTab[36206]"
//line /usr/local/go/src/mime/multipart/multipart.go:178
	_go_fuzz_dep_.CoverTab[36207]++
								return err
//line /usr/local/go/src/mime/multipart/multipart.go:179
	// _ = "end of CoverTab[36207]"
}

// Read reads the body of a part, after its headers and before the
//line /usr/local/go/src/mime/multipart/multipart.go:182
// next part (if any) begins.
//line /usr/local/go/src/mime/multipart/multipart.go:184
func (p *Part) Read(d []byte) (n int, err error) {
//line /usr/local/go/src/mime/multipart/multipart.go:184
	_go_fuzz_dep_.CoverTab[36213]++
								return p.r.Read(d)
//line /usr/local/go/src/mime/multipart/multipart.go:185
	// _ = "end of CoverTab[36213]"
}

// partReader implements io.Reader by reading raw bytes directly from the
//line /usr/local/go/src/mime/multipart/multipart.go:188
// wrapped *Part, without doing any Transfer-Encoding decoding.
//line /usr/local/go/src/mime/multipart/multipart.go:190
type partReader struct {
	p *Part
}

func (pr partReader) Read(d []byte) (int, error) {
//line /usr/local/go/src/mime/multipart/multipart.go:194
	_go_fuzz_dep_.CoverTab[36214]++
								p := pr.p
								br := p.mr.bufReader

//line /usr/local/go/src/mime/multipart/multipart.go:200
	for p.n == 0 && func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:200
		_go_fuzz_dep_.CoverTab[36219]++
//line /usr/local/go/src/mime/multipart/multipart.go:200
		return p.err == nil
//line /usr/local/go/src/mime/multipart/multipart.go:200
		// _ = "end of CoverTab[36219]"
//line /usr/local/go/src/mime/multipart/multipart.go:200
	}() {
//line /usr/local/go/src/mime/multipart/multipart.go:200
		_go_fuzz_dep_.CoverTab[36220]++
									peek, _ := br.Peek(br.Buffered())
									p.n, p.err = scanUntilBoundary(peek, p.mr.dashBoundary, p.mr.nlDashBoundary, p.total, p.readErr)
									if p.n == 0 && func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:203
			_go_fuzz_dep_.CoverTab[36221]++
//line /usr/local/go/src/mime/multipart/multipart.go:203
			return p.err == nil
//line /usr/local/go/src/mime/multipart/multipart.go:203
			// _ = "end of CoverTab[36221]"
//line /usr/local/go/src/mime/multipart/multipart.go:203
		}() {
//line /usr/local/go/src/mime/multipart/multipart.go:203
			_go_fuzz_dep_.CoverTab[36222]++

										_, p.readErr = br.Peek(len(peek) + 1)
										if p.readErr == io.EOF {
//line /usr/local/go/src/mime/multipart/multipart.go:206
				_go_fuzz_dep_.CoverTab[36223]++
											p.readErr = io.ErrUnexpectedEOF
//line /usr/local/go/src/mime/multipart/multipart.go:207
				// _ = "end of CoverTab[36223]"
			} else {
//line /usr/local/go/src/mime/multipart/multipart.go:208
				_go_fuzz_dep_.CoverTab[36224]++
//line /usr/local/go/src/mime/multipart/multipart.go:208
				// _ = "end of CoverTab[36224]"
//line /usr/local/go/src/mime/multipart/multipart.go:208
			}
//line /usr/local/go/src/mime/multipart/multipart.go:208
			// _ = "end of CoverTab[36222]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:209
			_go_fuzz_dep_.CoverTab[36225]++
//line /usr/local/go/src/mime/multipart/multipart.go:209
			// _ = "end of CoverTab[36225]"
//line /usr/local/go/src/mime/multipart/multipart.go:209
		}
//line /usr/local/go/src/mime/multipart/multipart.go:209
		// _ = "end of CoverTab[36220]"
	}
//line /usr/local/go/src/mime/multipart/multipart.go:210
	// _ = "end of CoverTab[36214]"
//line /usr/local/go/src/mime/multipart/multipart.go:210
	_go_fuzz_dep_.CoverTab[36215]++

//line /usr/local/go/src/mime/multipart/multipart.go:213
	if p.n == 0 {
//line /usr/local/go/src/mime/multipart/multipart.go:213
		_go_fuzz_dep_.CoverTab[36226]++
									return 0, p.err
//line /usr/local/go/src/mime/multipart/multipart.go:214
		// _ = "end of CoverTab[36226]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:215
		_go_fuzz_dep_.CoverTab[36227]++
//line /usr/local/go/src/mime/multipart/multipart.go:215
		// _ = "end of CoverTab[36227]"
//line /usr/local/go/src/mime/multipart/multipart.go:215
	}
//line /usr/local/go/src/mime/multipart/multipart.go:215
	// _ = "end of CoverTab[36215]"
//line /usr/local/go/src/mime/multipart/multipart.go:215
	_go_fuzz_dep_.CoverTab[36216]++
								n := len(d)
								if n > p.n {
//line /usr/local/go/src/mime/multipart/multipart.go:217
		_go_fuzz_dep_.CoverTab[36228]++
									n = p.n
//line /usr/local/go/src/mime/multipart/multipart.go:218
		// _ = "end of CoverTab[36228]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:219
		_go_fuzz_dep_.CoverTab[36229]++
//line /usr/local/go/src/mime/multipart/multipart.go:219
		// _ = "end of CoverTab[36229]"
//line /usr/local/go/src/mime/multipart/multipart.go:219
	}
//line /usr/local/go/src/mime/multipart/multipart.go:219
	// _ = "end of CoverTab[36216]"
//line /usr/local/go/src/mime/multipart/multipart.go:219
	_go_fuzz_dep_.CoverTab[36217]++
								n, _ = br.Read(d[:n])
								p.total += int64(n)
								p.n -= n
								if p.n == 0 {
//line /usr/local/go/src/mime/multipart/multipart.go:223
		_go_fuzz_dep_.CoverTab[36230]++
									return n, p.err
//line /usr/local/go/src/mime/multipart/multipart.go:224
		// _ = "end of CoverTab[36230]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:225
		_go_fuzz_dep_.CoverTab[36231]++
//line /usr/local/go/src/mime/multipart/multipart.go:225
		// _ = "end of CoverTab[36231]"
//line /usr/local/go/src/mime/multipart/multipart.go:225
	}
//line /usr/local/go/src/mime/multipart/multipart.go:225
	// _ = "end of CoverTab[36217]"
//line /usr/local/go/src/mime/multipart/multipart.go:225
	_go_fuzz_dep_.CoverTab[36218]++
								return n, nil
//line /usr/local/go/src/mime/multipart/multipart.go:226
	// _ = "end of CoverTab[36218]"
}

// scanUntilBoundary scans buf to identify how much of it can be safely
//line /usr/local/go/src/mime/multipart/multipart.go:229
// returned as part of the Part body.
//line /usr/local/go/src/mime/multipart/multipart.go:229
// dashBoundary is "--boundary".
//line /usr/local/go/src/mime/multipart/multipart.go:229
// nlDashBoundary is "\r\n--boundary" or "\n--boundary", depending on what mode we are in.
//line /usr/local/go/src/mime/multipart/multipart.go:229
// The comments below (and the name) assume "\n--boundary", but either is accepted.
//line /usr/local/go/src/mime/multipart/multipart.go:229
// total is the number of bytes read out so far. If total == 0, then a leading "--boundary" is recognized.
//line /usr/local/go/src/mime/multipart/multipart.go:229
// readErr is the read error, if any, that followed reading the bytes in buf.
//line /usr/local/go/src/mime/multipart/multipart.go:229
// scanUntilBoundary returns the number of data bytes from buf that can be
//line /usr/local/go/src/mime/multipart/multipart.go:229
// returned as part of the Part body and also the error to return (if any)
//line /usr/local/go/src/mime/multipart/multipart.go:229
// once those data bytes are done.
//line /usr/local/go/src/mime/multipart/multipart.go:239
func scanUntilBoundary(buf, dashBoundary, nlDashBoundary []byte, total int64, readErr error) (int, error) {
//line /usr/local/go/src/mime/multipart/multipart.go:239
	_go_fuzz_dep_.CoverTab[36232]++
								if total == 0 {
//line /usr/local/go/src/mime/multipart/multipart.go:240
		_go_fuzz_dep_.CoverTab[36237]++

									if bytes.HasPrefix(buf, dashBoundary) {
//line /usr/local/go/src/mime/multipart/multipart.go:242
			_go_fuzz_dep_.CoverTab[36239]++
										switch matchAfterPrefix(buf, dashBoundary, readErr) {
			case -1:
//line /usr/local/go/src/mime/multipart/multipart.go:244
				_go_fuzz_dep_.CoverTab[36240]++
											return len(dashBoundary), nil
//line /usr/local/go/src/mime/multipart/multipart.go:245
				// _ = "end of CoverTab[36240]"
			case 0:
//line /usr/local/go/src/mime/multipart/multipart.go:246
				_go_fuzz_dep_.CoverTab[36241]++
											return 0, nil
//line /usr/local/go/src/mime/multipart/multipart.go:247
				// _ = "end of CoverTab[36241]"
			case +1:
//line /usr/local/go/src/mime/multipart/multipart.go:248
				_go_fuzz_dep_.CoverTab[36242]++
											return 0, io.EOF
//line /usr/local/go/src/mime/multipart/multipart.go:249
				// _ = "end of CoverTab[36242]"
//line /usr/local/go/src/mime/multipart/multipart.go:249
			default:
//line /usr/local/go/src/mime/multipart/multipart.go:249
				_go_fuzz_dep_.CoverTab[36243]++
//line /usr/local/go/src/mime/multipart/multipart.go:249
				// _ = "end of CoverTab[36243]"
			}
//line /usr/local/go/src/mime/multipart/multipart.go:250
			// _ = "end of CoverTab[36239]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:251
			_go_fuzz_dep_.CoverTab[36244]++
//line /usr/local/go/src/mime/multipart/multipart.go:251
			// _ = "end of CoverTab[36244]"
//line /usr/local/go/src/mime/multipart/multipart.go:251
		}
//line /usr/local/go/src/mime/multipart/multipart.go:251
		// _ = "end of CoverTab[36237]"
//line /usr/local/go/src/mime/multipart/multipart.go:251
		_go_fuzz_dep_.CoverTab[36238]++
									if bytes.HasPrefix(dashBoundary, buf) {
//line /usr/local/go/src/mime/multipart/multipart.go:252
			_go_fuzz_dep_.CoverTab[36245]++
										return 0, readErr
//line /usr/local/go/src/mime/multipart/multipart.go:253
			// _ = "end of CoverTab[36245]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:254
			_go_fuzz_dep_.CoverTab[36246]++
//line /usr/local/go/src/mime/multipart/multipart.go:254
			// _ = "end of CoverTab[36246]"
//line /usr/local/go/src/mime/multipart/multipart.go:254
		}
//line /usr/local/go/src/mime/multipart/multipart.go:254
		// _ = "end of CoverTab[36238]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:255
		_go_fuzz_dep_.CoverTab[36247]++
//line /usr/local/go/src/mime/multipart/multipart.go:255
		// _ = "end of CoverTab[36247]"
//line /usr/local/go/src/mime/multipart/multipart.go:255
	}
//line /usr/local/go/src/mime/multipart/multipart.go:255
	// _ = "end of CoverTab[36232]"
//line /usr/local/go/src/mime/multipart/multipart.go:255
	_go_fuzz_dep_.CoverTab[36233]++

//line /usr/local/go/src/mime/multipart/multipart.go:258
	if i := bytes.Index(buf, nlDashBoundary); i >= 0 {
//line /usr/local/go/src/mime/multipart/multipart.go:258
		_go_fuzz_dep_.CoverTab[36248]++
									switch matchAfterPrefix(buf[i:], nlDashBoundary, readErr) {
		case -1:
//line /usr/local/go/src/mime/multipart/multipart.go:260
			_go_fuzz_dep_.CoverTab[36249]++
										return i + len(nlDashBoundary), nil
//line /usr/local/go/src/mime/multipart/multipart.go:261
			// _ = "end of CoverTab[36249]"
		case 0:
//line /usr/local/go/src/mime/multipart/multipart.go:262
			_go_fuzz_dep_.CoverTab[36250]++
										return i, nil
//line /usr/local/go/src/mime/multipart/multipart.go:263
			// _ = "end of CoverTab[36250]"
		case +1:
//line /usr/local/go/src/mime/multipart/multipart.go:264
			_go_fuzz_dep_.CoverTab[36251]++
										return i, io.EOF
//line /usr/local/go/src/mime/multipart/multipart.go:265
			// _ = "end of CoverTab[36251]"
//line /usr/local/go/src/mime/multipart/multipart.go:265
		default:
//line /usr/local/go/src/mime/multipart/multipart.go:265
			_go_fuzz_dep_.CoverTab[36252]++
//line /usr/local/go/src/mime/multipart/multipart.go:265
			// _ = "end of CoverTab[36252]"
		}
//line /usr/local/go/src/mime/multipart/multipart.go:266
		// _ = "end of CoverTab[36248]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:267
		_go_fuzz_dep_.CoverTab[36253]++
//line /usr/local/go/src/mime/multipart/multipart.go:267
		// _ = "end of CoverTab[36253]"
//line /usr/local/go/src/mime/multipart/multipart.go:267
	}
//line /usr/local/go/src/mime/multipart/multipart.go:267
	// _ = "end of CoverTab[36233]"
//line /usr/local/go/src/mime/multipart/multipart.go:267
	_go_fuzz_dep_.CoverTab[36234]++
								if bytes.HasPrefix(nlDashBoundary, buf) {
//line /usr/local/go/src/mime/multipart/multipart.go:268
		_go_fuzz_dep_.CoverTab[36254]++
									return 0, readErr
//line /usr/local/go/src/mime/multipart/multipart.go:269
		// _ = "end of CoverTab[36254]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:270
		_go_fuzz_dep_.CoverTab[36255]++
//line /usr/local/go/src/mime/multipart/multipart.go:270
		// _ = "end of CoverTab[36255]"
//line /usr/local/go/src/mime/multipart/multipart.go:270
	}
//line /usr/local/go/src/mime/multipart/multipart.go:270
	// _ = "end of CoverTab[36234]"
//line /usr/local/go/src/mime/multipart/multipart.go:270
	_go_fuzz_dep_.CoverTab[36235]++

//line /usr/local/go/src/mime/multipart/multipart.go:276
	i := bytes.LastIndexByte(buf, nlDashBoundary[0])
	if i >= 0 && func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:277
		_go_fuzz_dep_.CoverTab[36256]++
//line /usr/local/go/src/mime/multipart/multipart.go:277
		return bytes.HasPrefix(nlDashBoundary, buf[i:])
//line /usr/local/go/src/mime/multipart/multipart.go:277
		// _ = "end of CoverTab[36256]"
//line /usr/local/go/src/mime/multipart/multipart.go:277
	}() {
//line /usr/local/go/src/mime/multipart/multipart.go:277
		_go_fuzz_dep_.CoverTab[36257]++
									return i, nil
//line /usr/local/go/src/mime/multipart/multipart.go:278
		// _ = "end of CoverTab[36257]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:279
		_go_fuzz_dep_.CoverTab[36258]++
//line /usr/local/go/src/mime/multipart/multipart.go:279
		// _ = "end of CoverTab[36258]"
//line /usr/local/go/src/mime/multipart/multipart.go:279
	}
//line /usr/local/go/src/mime/multipart/multipart.go:279
	// _ = "end of CoverTab[36235]"
//line /usr/local/go/src/mime/multipart/multipart.go:279
	_go_fuzz_dep_.CoverTab[36236]++
								return len(buf), readErr
//line /usr/local/go/src/mime/multipart/multipart.go:280
	// _ = "end of CoverTab[36236]"
}

// matchAfterPrefix checks whether buf should be considered to match the boundary.
//line /usr/local/go/src/mime/multipart/multipart.go:283
// The prefix is "--boundary" or "\r\n--boundary" or "\n--boundary",
//line /usr/local/go/src/mime/multipart/multipart.go:283
// and the caller has verified already that bytes.HasPrefix(buf, prefix) is true.
//line /usr/local/go/src/mime/multipart/multipart.go:283
//
//line /usr/local/go/src/mime/multipart/multipart.go:283
// matchAfterPrefix returns +1 if the buffer does match the boundary,
//line /usr/local/go/src/mime/multipart/multipart.go:283
// meaning the prefix is followed by a double dash, space, tab, cr, nl,
//line /usr/local/go/src/mime/multipart/multipart.go:283
// or end of input.
//line /usr/local/go/src/mime/multipart/multipart.go:283
// It returns -1 if the buffer definitely does NOT match the boundary,
//line /usr/local/go/src/mime/multipart/multipart.go:283
// meaning the prefix is followed by some other character.
//line /usr/local/go/src/mime/multipart/multipart.go:283
// For example, "--foobar" does not match "--foo".
//line /usr/local/go/src/mime/multipart/multipart.go:283
// It returns 0 more input needs to be read to make the decision,
//line /usr/local/go/src/mime/multipart/multipart.go:283
// meaning that len(buf) == len(prefix) and readErr == nil.
//line /usr/local/go/src/mime/multipart/multipart.go:295
func matchAfterPrefix(buf, prefix []byte, readErr error) int {
//line /usr/local/go/src/mime/multipart/multipart.go:295
	_go_fuzz_dep_.CoverTab[36259]++
								if len(buf) == len(prefix) {
//line /usr/local/go/src/mime/multipart/multipart.go:296
		_go_fuzz_dep_.CoverTab[36263]++
									if readErr != nil {
//line /usr/local/go/src/mime/multipart/multipart.go:297
			_go_fuzz_dep_.CoverTab[36265]++
										return +1
//line /usr/local/go/src/mime/multipart/multipart.go:298
			// _ = "end of CoverTab[36265]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:299
			_go_fuzz_dep_.CoverTab[36266]++
//line /usr/local/go/src/mime/multipart/multipart.go:299
			// _ = "end of CoverTab[36266]"
//line /usr/local/go/src/mime/multipart/multipart.go:299
		}
//line /usr/local/go/src/mime/multipart/multipart.go:299
		// _ = "end of CoverTab[36263]"
//line /usr/local/go/src/mime/multipart/multipart.go:299
		_go_fuzz_dep_.CoverTab[36264]++
									return 0
//line /usr/local/go/src/mime/multipart/multipart.go:300
		// _ = "end of CoverTab[36264]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:301
		_go_fuzz_dep_.CoverTab[36267]++
//line /usr/local/go/src/mime/multipart/multipart.go:301
		// _ = "end of CoverTab[36267]"
//line /usr/local/go/src/mime/multipart/multipart.go:301
	}
//line /usr/local/go/src/mime/multipart/multipart.go:301
	// _ = "end of CoverTab[36259]"
//line /usr/local/go/src/mime/multipart/multipart.go:301
	_go_fuzz_dep_.CoverTab[36260]++
								c := buf[len(prefix)]

								if c == ' ' || func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:304
		_go_fuzz_dep_.CoverTab[36268]++
//line /usr/local/go/src/mime/multipart/multipart.go:304
		return c == '\t'
//line /usr/local/go/src/mime/multipart/multipart.go:304
		// _ = "end of CoverTab[36268]"
//line /usr/local/go/src/mime/multipart/multipart.go:304
	}() || func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:304
		_go_fuzz_dep_.CoverTab[36269]++
//line /usr/local/go/src/mime/multipart/multipart.go:304
		return c == '\r'
//line /usr/local/go/src/mime/multipart/multipart.go:304
		// _ = "end of CoverTab[36269]"
//line /usr/local/go/src/mime/multipart/multipart.go:304
	}() || func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:304
		_go_fuzz_dep_.CoverTab[36270]++
//line /usr/local/go/src/mime/multipart/multipart.go:304
		return c == '\n'
//line /usr/local/go/src/mime/multipart/multipart.go:304
		// _ = "end of CoverTab[36270]"
//line /usr/local/go/src/mime/multipart/multipart.go:304
	}() {
//line /usr/local/go/src/mime/multipart/multipart.go:304
		_go_fuzz_dep_.CoverTab[36271]++
									return +1
//line /usr/local/go/src/mime/multipart/multipart.go:305
		// _ = "end of CoverTab[36271]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:306
		_go_fuzz_dep_.CoverTab[36272]++
//line /usr/local/go/src/mime/multipart/multipart.go:306
		// _ = "end of CoverTab[36272]"
//line /usr/local/go/src/mime/multipart/multipart.go:306
	}
//line /usr/local/go/src/mime/multipart/multipart.go:306
	// _ = "end of CoverTab[36260]"
//line /usr/local/go/src/mime/multipart/multipart.go:306
	_go_fuzz_dep_.CoverTab[36261]++

//line /usr/local/go/src/mime/multipart/multipart.go:309
	if c == '-' {
//line /usr/local/go/src/mime/multipart/multipart.go:309
		_go_fuzz_dep_.CoverTab[36273]++
									if len(buf) == len(prefix)+1 {
//line /usr/local/go/src/mime/multipart/multipart.go:310
			_go_fuzz_dep_.CoverTab[36275]++
										if readErr != nil {
//line /usr/local/go/src/mime/multipart/multipart.go:311
				_go_fuzz_dep_.CoverTab[36277]++

											return -1
//line /usr/local/go/src/mime/multipart/multipart.go:313
				// _ = "end of CoverTab[36277]"
			} else {
//line /usr/local/go/src/mime/multipart/multipart.go:314
				_go_fuzz_dep_.CoverTab[36278]++
//line /usr/local/go/src/mime/multipart/multipart.go:314
				// _ = "end of CoverTab[36278]"
//line /usr/local/go/src/mime/multipart/multipart.go:314
			}
//line /usr/local/go/src/mime/multipart/multipart.go:314
			// _ = "end of CoverTab[36275]"
//line /usr/local/go/src/mime/multipart/multipart.go:314
			_go_fuzz_dep_.CoverTab[36276]++
										return 0
//line /usr/local/go/src/mime/multipart/multipart.go:315
			// _ = "end of CoverTab[36276]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:316
			_go_fuzz_dep_.CoverTab[36279]++
//line /usr/local/go/src/mime/multipart/multipart.go:316
			// _ = "end of CoverTab[36279]"
//line /usr/local/go/src/mime/multipart/multipart.go:316
		}
//line /usr/local/go/src/mime/multipart/multipart.go:316
		// _ = "end of CoverTab[36273]"
//line /usr/local/go/src/mime/multipart/multipart.go:316
		_go_fuzz_dep_.CoverTab[36274]++
									if buf[len(prefix)+1] == '-' {
//line /usr/local/go/src/mime/multipart/multipart.go:317
			_go_fuzz_dep_.CoverTab[36280]++
										return +1
//line /usr/local/go/src/mime/multipart/multipart.go:318
			// _ = "end of CoverTab[36280]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:319
			_go_fuzz_dep_.CoverTab[36281]++
//line /usr/local/go/src/mime/multipart/multipart.go:319
			// _ = "end of CoverTab[36281]"
//line /usr/local/go/src/mime/multipart/multipart.go:319
		}
//line /usr/local/go/src/mime/multipart/multipart.go:319
		// _ = "end of CoverTab[36274]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:320
		_go_fuzz_dep_.CoverTab[36282]++
//line /usr/local/go/src/mime/multipart/multipart.go:320
		// _ = "end of CoverTab[36282]"
//line /usr/local/go/src/mime/multipart/multipart.go:320
	}
//line /usr/local/go/src/mime/multipart/multipart.go:320
	// _ = "end of CoverTab[36261]"
//line /usr/local/go/src/mime/multipart/multipart.go:320
	_go_fuzz_dep_.CoverTab[36262]++

								return -1
//line /usr/local/go/src/mime/multipart/multipart.go:322
	// _ = "end of CoverTab[36262]"
}

func (p *Part) Close() error {
//line /usr/local/go/src/mime/multipart/multipart.go:325
	_go_fuzz_dep_.CoverTab[36283]++
								io.Copy(io.Discard, p)
								return nil
//line /usr/local/go/src/mime/multipart/multipart.go:327
	// _ = "end of CoverTab[36283]"
}

// Reader is an iterator over parts in a MIME multipart body.
//line /usr/local/go/src/mime/multipart/multipart.go:330
// Reader's underlying parser consumes its input as needed. Seeking
//line /usr/local/go/src/mime/multipart/multipart.go:330
// isn't supported.
//line /usr/local/go/src/mime/multipart/multipart.go:333
type Reader struct {
	bufReader	*bufio.Reader
	tempDir		string	// used in tests

	currentPart	*Part
	partsRead	int

	nl			[]byte	// "\r\n" or "\n" (set after seeing first boundary line)
	nlDashBoundary		[]byte	// nl + "--boundary"
	dashBoundaryDash	[]byte	// "--boundary--"
	dashBoundary		[]byte	// "--boundary"
}

// maxMIMEHeaderSize is the maximum size of a MIME header we will parse,
//line /usr/local/go/src/mime/multipart/multipart.go:346
// including header keys, values, and map overhead.
//line /usr/local/go/src/mime/multipart/multipart.go:348
const maxMIMEHeaderSize = 10 << 20

// multipartMaxHeaders is the maximum number of header entries NextPart will return,
//line /usr/local/go/src/mime/multipart/multipart.go:350
// as well as the maximum combined total of header entries Reader.ReadForm will return
//line /usr/local/go/src/mime/multipart/multipart.go:350
// in FileHeaders.
//line /usr/local/go/src/mime/multipart/multipart.go:353
var multipartMaxHeaders = godebug.New("multipartmaxheaders")

func maxMIMEHeaders() int64 {
//line /usr/local/go/src/mime/multipart/multipart.go:355
	_go_fuzz_dep_.CoverTab[36284]++
								if s := multipartMaxHeaders.Value(); s != "" {
//line /usr/local/go/src/mime/multipart/multipart.go:356
		_go_fuzz_dep_.CoverTab[36286]++
									if v, err := strconv.ParseInt(s, 10, 64); err == nil && func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:357
			_go_fuzz_dep_.CoverTab[36287]++
//line /usr/local/go/src/mime/multipart/multipart.go:357
			return v >= 0
//line /usr/local/go/src/mime/multipart/multipart.go:357
			// _ = "end of CoverTab[36287]"
//line /usr/local/go/src/mime/multipart/multipart.go:357
		}() {
//line /usr/local/go/src/mime/multipart/multipart.go:357
			_go_fuzz_dep_.CoverTab[36288]++
										return v
//line /usr/local/go/src/mime/multipart/multipart.go:358
			// _ = "end of CoverTab[36288]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:359
			_go_fuzz_dep_.CoverTab[36289]++
//line /usr/local/go/src/mime/multipart/multipart.go:359
			// _ = "end of CoverTab[36289]"
//line /usr/local/go/src/mime/multipart/multipart.go:359
		}
//line /usr/local/go/src/mime/multipart/multipart.go:359
		// _ = "end of CoverTab[36286]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:360
		_go_fuzz_dep_.CoverTab[36290]++
//line /usr/local/go/src/mime/multipart/multipart.go:360
		// _ = "end of CoverTab[36290]"
//line /usr/local/go/src/mime/multipart/multipart.go:360
	}
//line /usr/local/go/src/mime/multipart/multipart.go:360
	// _ = "end of CoverTab[36284]"
//line /usr/local/go/src/mime/multipart/multipart.go:360
	_go_fuzz_dep_.CoverTab[36285]++
								return 10000
//line /usr/local/go/src/mime/multipart/multipart.go:361
	// _ = "end of CoverTab[36285]"
}

// NextPart returns the next part in the multipart or an error.
//line /usr/local/go/src/mime/multipart/multipart.go:364
// When there are no more parts, the error io.EOF is returned.
//line /usr/local/go/src/mime/multipart/multipart.go:364
//
//line /usr/local/go/src/mime/multipart/multipart.go:364
// As a special case, if the "Content-Transfer-Encoding" header
//line /usr/local/go/src/mime/multipart/multipart.go:364
// has a value of "quoted-printable", that header is instead
//line /usr/local/go/src/mime/multipart/multipart.go:364
// hidden and the body is transparently decoded during Read calls.
//line /usr/local/go/src/mime/multipart/multipart.go:370
func (r *Reader) NextPart() (*Part, error) {
//line /usr/local/go/src/mime/multipart/multipart.go:370
	_go_fuzz_dep_.CoverTab[36291]++
								return r.nextPart(false, maxMIMEHeaderSize, maxMIMEHeaders())
//line /usr/local/go/src/mime/multipart/multipart.go:371
	// _ = "end of CoverTab[36291]"
}

// NextRawPart returns the next part in the multipart or an error.
//line /usr/local/go/src/mime/multipart/multipart.go:374
// When there are no more parts, the error io.EOF is returned.
//line /usr/local/go/src/mime/multipart/multipart.go:374
//
//line /usr/local/go/src/mime/multipart/multipart.go:374
// Unlike NextPart, it does not have special handling for
//line /usr/local/go/src/mime/multipart/multipart.go:374
// "Content-Transfer-Encoding: quoted-printable".
//line /usr/local/go/src/mime/multipart/multipart.go:379
func (r *Reader) NextRawPart() (*Part, error) {
//line /usr/local/go/src/mime/multipart/multipart.go:379
	_go_fuzz_dep_.CoverTab[36292]++
								return r.nextPart(true, maxMIMEHeaderSize, maxMIMEHeaders())
//line /usr/local/go/src/mime/multipart/multipart.go:380
	// _ = "end of CoverTab[36292]"
}

func (r *Reader) nextPart(rawPart bool, maxMIMEHeaderSize, maxMIMEHeaders int64) (*Part, error) {
//line /usr/local/go/src/mime/multipart/multipart.go:383
	_go_fuzz_dep_.CoverTab[36293]++
								if r.currentPart != nil {
//line /usr/local/go/src/mime/multipart/multipart.go:384
		_go_fuzz_dep_.CoverTab[36296]++
									r.currentPart.Close()
//line /usr/local/go/src/mime/multipart/multipart.go:385
		// _ = "end of CoverTab[36296]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:386
		_go_fuzz_dep_.CoverTab[36297]++
//line /usr/local/go/src/mime/multipart/multipart.go:386
		// _ = "end of CoverTab[36297]"
//line /usr/local/go/src/mime/multipart/multipart.go:386
	}
//line /usr/local/go/src/mime/multipart/multipart.go:386
	// _ = "end of CoverTab[36293]"
//line /usr/local/go/src/mime/multipart/multipart.go:386
	_go_fuzz_dep_.CoverTab[36294]++
								if string(r.dashBoundary) == "--" {
//line /usr/local/go/src/mime/multipart/multipart.go:387
		_go_fuzz_dep_.CoverTab[36298]++
									return nil, fmt.Errorf("multipart: boundary is empty")
//line /usr/local/go/src/mime/multipart/multipart.go:388
		// _ = "end of CoverTab[36298]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:389
		_go_fuzz_dep_.CoverTab[36299]++
//line /usr/local/go/src/mime/multipart/multipart.go:389
		// _ = "end of CoverTab[36299]"
//line /usr/local/go/src/mime/multipart/multipart.go:389
	}
//line /usr/local/go/src/mime/multipart/multipart.go:389
	// _ = "end of CoverTab[36294]"
//line /usr/local/go/src/mime/multipart/multipart.go:389
	_go_fuzz_dep_.CoverTab[36295]++
								expectNewPart := false
								for {
//line /usr/local/go/src/mime/multipart/multipart.go:391
		_go_fuzz_dep_.CoverTab[36300]++
									line, err := r.bufReader.ReadSlice('\n')

									if err == io.EOF && func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:394
			_go_fuzz_dep_.CoverTab[36308]++
//line /usr/local/go/src/mime/multipart/multipart.go:394
			return r.isFinalBoundary(line)
//line /usr/local/go/src/mime/multipart/multipart.go:394
			// _ = "end of CoverTab[36308]"
//line /usr/local/go/src/mime/multipart/multipart.go:394
		}() {
//line /usr/local/go/src/mime/multipart/multipart.go:394
			_go_fuzz_dep_.CoverTab[36309]++

//line /usr/local/go/src/mime/multipart/multipart.go:400
			return nil, io.EOF
//line /usr/local/go/src/mime/multipart/multipart.go:400
			// _ = "end of CoverTab[36309]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:401
			_go_fuzz_dep_.CoverTab[36310]++
//line /usr/local/go/src/mime/multipart/multipart.go:401
			// _ = "end of CoverTab[36310]"
//line /usr/local/go/src/mime/multipart/multipart.go:401
		}
//line /usr/local/go/src/mime/multipart/multipart.go:401
		// _ = "end of CoverTab[36300]"
//line /usr/local/go/src/mime/multipart/multipart.go:401
		_go_fuzz_dep_.CoverTab[36301]++
									if err != nil {
//line /usr/local/go/src/mime/multipart/multipart.go:402
			_go_fuzz_dep_.CoverTab[36311]++
										return nil, fmt.Errorf("multipart: NextPart: %w", err)
//line /usr/local/go/src/mime/multipart/multipart.go:403
			// _ = "end of CoverTab[36311]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:404
			_go_fuzz_dep_.CoverTab[36312]++
//line /usr/local/go/src/mime/multipart/multipart.go:404
			// _ = "end of CoverTab[36312]"
//line /usr/local/go/src/mime/multipart/multipart.go:404
		}
//line /usr/local/go/src/mime/multipart/multipart.go:404
		// _ = "end of CoverTab[36301]"
//line /usr/local/go/src/mime/multipart/multipart.go:404
		_go_fuzz_dep_.CoverTab[36302]++

									if r.isBoundaryDelimiterLine(line) {
//line /usr/local/go/src/mime/multipart/multipart.go:406
			_go_fuzz_dep_.CoverTab[36313]++
										r.partsRead++
										bp, err := newPart(r, rawPart, maxMIMEHeaderSize, maxMIMEHeaders)
										if err != nil {
//line /usr/local/go/src/mime/multipart/multipart.go:409
				_go_fuzz_dep_.CoverTab[36315]++
											return nil, err
//line /usr/local/go/src/mime/multipart/multipart.go:410
				// _ = "end of CoverTab[36315]"
			} else {
//line /usr/local/go/src/mime/multipart/multipart.go:411
				_go_fuzz_dep_.CoverTab[36316]++
//line /usr/local/go/src/mime/multipart/multipart.go:411
				// _ = "end of CoverTab[36316]"
//line /usr/local/go/src/mime/multipart/multipart.go:411
			}
//line /usr/local/go/src/mime/multipart/multipart.go:411
			// _ = "end of CoverTab[36313]"
//line /usr/local/go/src/mime/multipart/multipart.go:411
			_go_fuzz_dep_.CoverTab[36314]++
										r.currentPart = bp
										return bp, nil
//line /usr/local/go/src/mime/multipart/multipart.go:413
			// _ = "end of CoverTab[36314]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:414
			_go_fuzz_dep_.CoverTab[36317]++
//line /usr/local/go/src/mime/multipart/multipart.go:414
			// _ = "end of CoverTab[36317]"
//line /usr/local/go/src/mime/multipart/multipart.go:414
		}
//line /usr/local/go/src/mime/multipart/multipart.go:414
		// _ = "end of CoverTab[36302]"
//line /usr/local/go/src/mime/multipart/multipart.go:414
		_go_fuzz_dep_.CoverTab[36303]++

									if r.isFinalBoundary(line) {
//line /usr/local/go/src/mime/multipart/multipart.go:416
			_go_fuzz_dep_.CoverTab[36318]++

										return nil, io.EOF
//line /usr/local/go/src/mime/multipart/multipart.go:418
			// _ = "end of CoverTab[36318]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:419
			_go_fuzz_dep_.CoverTab[36319]++
//line /usr/local/go/src/mime/multipart/multipart.go:419
			// _ = "end of CoverTab[36319]"
//line /usr/local/go/src/mime/multipart/multipart.go:419
		}
//line /usr/local/go/src/mime/multipart/multipart.go:419
		// _ = "end of CoverTab[36303]"
//line /usr/local/go/src/mime/multipart/multipart.go:419
		_go_fuzz_dep_.CoverTab[36304]++

									if expectNewPart {
//line /usr/local/go/src/mime/multipart/multipart.go:421
			_go_fuzz_dep_.CoverTab[36320]++
										return nil, fmt.Errorf("multipart: expecting a new Part; got line %q", string(line))
//line /usr/local/go/src/mime/multipart/multipart.go:422
			// _ = "end of CoverTab[36320]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:423
			_go_fuzz_dep_.CoverTab[36321]++
//line /usr/local/go/src/mime/multipart/multipart.go:423
			// _ = "end of CoverTab[36321]"
//line /usr/local/go/src/mime/multipart/multipart.go:423
		}
//line /usr/local/go/src/mime/multipart/multipart.go:423
		// _ = "end of CoverTab[36304]"
//line /usr/local/go/src/mime/multipart/multipart.go:423
		_go_fuzz_dep_.CoverTab[36305]++

									if r.partsRead == 0 {
//line /usr/local/go/src/mime/multipart/multipart.go:425
			_go_fuzz_dep_.CoverTab[36322]++

										continue
//line /usr/local/go/src/mime/multipart/multipart.go:427
			// _ = "end of CoverTab[36322]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:428
			_go_fuzz_dep_.CoverTab[36323]++
//line /usr/local/go/src/mime/multipart/multipart.go:428
			// _ = "end of CoverTab[36323]"
//line /usr/local/go/src/mime/multipart/multipart.go:428
		}
//line /usr/local/go/src/mime/multipart/multipart.go:428
		// _ = "end of CoverTab[36305]"
//line /usr/local/go/src/mime/multipart/multipart.go:428
		_go_fuzz_dep_.CoverTab[36306]++

//line /usr/local/go/src/mime/multipart/multipart.go:434
		if bytes.Equal(line, r.nl) {
//line /usr/local/go/src/mime/multipart/multipart.go:434
			_go_fuzz_dep_.CoverTab[36324]++
										expectNewPart = true
										continue
//line /usr/local/go/src/mime/multipart/multipart.go:436
			// _ = "end of CoverTab[36324]"
		} else {
//line /usr/local/go/src/mime/multipart/multipart.go:437
			_go_fuzz_dep_.CoverTab[36325]++
//line /usr/local/go/src/mime/multipart/multipart.go:437
			// _ = "end of CoverTab[36325]"
//line /usr/local/go/src/mime/multipart/multipart.go:437
		}
//line /usr/local/go/src/mime/multipart/multipart.go:437
		// _ = "end of CoverTab[36306]"
//line /usr/local/go/src/mime/multipart/multipart.go:437
		_go_fuzz_dep_.CoverTab[36307]++

									return nil, fmt.Errorf("multipart: unexpected line in Next(): %q", line)
//line /usr/local/go/src/mime/multipart/multipart.go:439
		// _ = "end of CoverTab[36307]"
	}
//line /usr/local/go/src/mime/multipart/multipart.go:440
	// _ = "end of CoverTab[36295]"
}

// isFinalBoundary reports whether line is the final boundary line
//line /usr/local/go/src/mime/multipart/multipart.go:443
// indicating that all parts are over.
//line /usr/local/go/src/mime/multipart/multipart.go:443
// It matches `^--boundary--[ \t]*(\r\n)?$`
//line /usr/local/go/src/mime/multipart/multipart.go:446
func (r *Reader) isFinalBoundary(line []byte) bool {
//line /usr/local/go/src/mime/multipart/multipart.go:446
	_go_fuzz_dep_.CoverTab[36326]++
								if !bytes.HasPrefix(line, r.dashBoundaryDash) {
//line /usr/local/go/src/mime/multipart/multipart.go:447
		_go_fuzz_dep_.CoverTab[36328]++
									return false
//line /usr/local/go/src/mime/multipart/multipart.go:448
		// _ = "end of CoverTab[36328]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:449
		_go_fuzz_dep_.CoverTab[36329]++
//line /usr/local/go/src/mime/multipart/multipart.go:449
		// _ = "end of CoverTab[36329]"
//line /usr/local/go/src/mime/multipart/multipart.go:449
	}
//line /usr/local/go/src/mime/multipart/multipart.go:449
	// _ = "end of CoverTab[36326]"
//line /usr/local/go/src/mime/multipart/multipart.go:449
	_go_fuzz_dep_.CoverTab[36327]++
								rest := line[len(r.dashBoundaryDash):]
								rest = skipLWSPChar(rest)
								return len(rest) == 0 || func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:452
		_go_fuzz_dep_.CoverTab[36330]++
//line /usr/local/go/src/mime/multipart/multipart.go:452
		return bytes.Equal(rest, r.nl)
//line /usr/local/go/src/mime/multipart/multipart.go:452
		// _ = "end of CoverTab[36330]"
//line /usr/local/go/src/mime/multipart/multipart.go:452
	}()
//line /usr/local/go/src/mime/multipart/multipart.go:452
	// _ = "end of CoverTab[36327]"
}

func (r *Reader) isBoundaryDelimiterLine(line []byte) (ret bool) {
//line /usr/local/go/src/mime/multipart/multipart.go:455
	_go_fuzz_dep_.CoverTab[36331]++

//line /usr/local/go/src/mime/multipart/multipart.go:462
	if !bytes.HasPrefix(line, r.dashBoundary) {
//line /usr/local/go/src/mime/multipart/multipart.go:462
		_go_fuzz_dep_.CoverTab[36334]++
									return false
//line /usr/local/go/src/mime/multipart/multipart.go:463
		// _ = "end of CoverTab[36334]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:464
		_go_fuzz_dep_.CoverTab[36335]++
//line /usr/local/go/src/mime/multipart/multipart.go:464
		// _ = "end of CoverTab[36335]"
//line /usr/local/go/src/mime/multipart/multipart.go:464
	}
//line /usr/local/go/src/mime/multipart/multipart.go:464
	// _ = "end of CoverTab[36331]"
//line /usr/local/go/src/mime/multipart/multipart.go:464
	_go_fuzz_dep_.CoverTab[36332]++
								rest := line[len(r.dashBoundary):]
								rest = skipLWSPChar(rest)

//line /usr/local/go/src/mime/multipart/multipart.go:471
	if r.partsRead == 0 && func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:471
		_go_fuzz_dep_.CoverTab[36336]++
//line /usr/local/go/src/mime/multipart/multipart.go:471
		return len(rest) == 1
//line /usr/local/go/src/mime/multipart/multipart.go:471
		// _ = "end of CoverTab[36336]"
//line /usr/local/go/src/mime/multipart/multipart.go:471
	}() && func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:471
		_go_fuzz_dep_.CoverTab[36337]++
//line /usr/local/go/src/mime/multipart/multipart.go:471
		return rest[0] == '\n'
//line /usr/local/go/src/mime/multipart/multipart.go:471
		// _ = "end of CoverTab[36337]"
//line /usr/local/go/src/mime/multipart/multipart.go:471
	}() {
//line /usr/local/go/src/mime/multipart/multipart.go:471
		_go_fuzz_dep_.CoverTab[36338]++
									r.nl = r.nl[1:]
									r.nlDashBoundary = r.nlDashBoundary[1:]
//line /usr/local/go/src/mime/multipart/multipart.go:473
		// _ = "end of CoverTab[36338]"
	} else {
//line /usr/local/go/src/mime/multipart/multipart.go:474
		_go_fuzz_dep_.CoverTab[36339]++
//line /usr/local/go/src/mime/multipart/multipart.go:474
		// _ = "end of CoverTab[36339]"
//line /usr/local/go/src/mime/multipart/multipart.go:474
	}
//line /usr/local/go/src/mime/multipart/multipart.go:474
	// _ = "end of CoverTab[36332]"
//line /usr/local/go/src/mime/multipart/multipart.go:474
	_go_fuzz_dep_.CoverTab[36333]++
								return bytes.Equal(rest, r.nl)
//line /usr/local/go/src/mime/multipart/multipart.go:475
	// _ = "end of CoverTab[36333]"
}

// skipLWSPChar returns b with leading spaces and tabs removed.
//line /usr/local/go/src/mime/multipart/multipart.go:478
// RFC 822 defines:
//line /usr/local/go/src/mime/multipart/multipart.go:478
//
//line /usr/local/go/src/mime/multipart/multipart.go:478
//	LWSP-char = SPACE / HTAB
//line /usr/local/go/src/mime/multipart/multipart.go:482
func skipLWSPChar(b []byte) []byte {
//line /usr/local/go/src/mime/multipart/multipart.go:482
	_go_fuzz_dep_.CoverTab[36340]++
								for len(b) > 0 && func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:483
		_go_fuzz_dep_.CoverTab[36342]++
//line /usr/local/go/src/mime/multipart/multipart.go:483
		return (b[0] == ' ' || func() bool {
//line /usr/local/go/src/mime/multipart/multipart.go:483
			_go_fuzz_dep_.CoverTab[36343]++
//line /usr/local/go/src/mime/multipart/multipart.go:483
			return b[0] == '\t'
//line /usr/local/go/src/mime/multipart/multipart.go:483
			// _ = "end of CoverTab[36343]"
//line /usr/local/go/src/mime/multipart/multipart.go:483
		}())
//line /usr/local/go/src/mime/multipart/multipart.go:483
		// _ = "end of CoverTab[36342]"
//line /usr/local/go/src/mime/multipart/multipart.go:483
	}() {
//line /usr/local/go/src/mime/multipart/multipart.go:483
		_go_fuzz_dep_.CoverTab[36344]++
									b = b[1:]
//line /usr/local/go/src/mime/multipart/multipart.go:484
		// _ = "end of CoverTab[36344]"
	}
//line /usr/local/go/src/mime/multipart/multipart.go:485
	// _ = "end of CoverTab[36340]"
//line /usr/local/go/src/mime/multipart/multipart.go:485
	_go_fuzz_dep_.CoverTab[36341]++
								return b
//line /usr/local/go/src/mime/multipart/multipart.go:486
	// _ = "end of CoverTab[36341]"
}

//line /usr/local/go/src/mime/multipart/multipart.go:487
var _ = _atomic_.LoadUint32(&_go_fuzz_dep_.NoUse)
//line /usr/local/go/src/mime/multipart/multipart.go:487
var _ = _go_fuzz_dep_.CoverTab
