// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//line /usr/local/go/src/log/log.go:5
// Package log implements a simple logging package. It defines a type, Logger,
//line /usr/local/go/src/log/log.go:5
// with methods for formatting output. It also has a predefined 'standard'
//line /usr/local/go/src/log/log.go:5
// Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and
//line /usr/local/go/src/log/log.go:5
// Panic[f|ln], which are easier to use than creating a Logger manually.
//line /usr/local/go/src/log/log.go:5
// That logger writes to standard error and prints the date and time
//line /usr/local/go/src/log/log.go:5
// of each logged message.
//line /usr/local/go/src/log/log.go:5
// Every log message is output on a separate line: if the message being
//line /usr/local/go/src/log/log.go:5
// printed does not end in a newline, the logger will add one.
//line /usr/local/go/src/log/log.go:5
// The Fatal functions call os.Exit(1) after writing the log message.
//line /usr/local/go/src/log/log.go:5
// The Panic functions call panic after writing the log message.
//line /usr/local/go/src/log/log.go:15
package log

//line /usr/local/go/src/log/log.go:15
import (
//line /usr/local/go/src/log/log.go:15
	_go_fuzz_dep_ "go-fuzz-dep"
//line /usr/local/go/src/log/log.go:15
)
//line /usr/local/go/src/log/log.go:15
import (
//line /usr/local/go/src/log/log.go:15
	_atomic_ "sync/atomic"
//line /usr/local/go/src/log/log.go:15
)

import (
	"fmt"
	"io"
	"os"
	"runtime"
	"sync"
	"sync/atomic"
	"time"
)

// These flags define which text to prefix to each log entry generated by the Logger.
//line /usr/local/go/src/log/log.go:27
// Bits are or'ed together to control what's printed.
//line /usr/local/go/src/log/log.go:27
// With the exception of the Lmsgprefix flag, there is no
//line /usr/local/go/src/log/log.go:27
// control over the order they appear (the order listed here)
//line /usr/local/go/src/log/log.go:27
// or the format they present (as described in the comments).
//line /usr/local/go/src/log/log.go:27
// The prefix is followed by a colon only when Llongfile or Lshortfile
//line /usr/local/go/src/log/log.go:27
// is specified.
//line /usr/local/go/src/log/log.go:27
// For example, flags Ldate | Ltime (or LstdFlags) produce,
//line /usr/local/go/src/log/log.go:27
//
//line /usr/local/go/src/log/log.go:27
//	2009/01/23 01:23:23 message
//line /usr/local/go/src/log/log.go:27
//
//line /usr/local/go/src/log/log.go:27
// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
//line /usr/local/go/src/log/log.go:27
//
//line /usr/local/go/src/log/log.go:27
//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
//line /usr/local/go/src/log/log.go:41
const (
	Ldate		= 1 << iota	// the date in the local time zone: 2009/01/23
	Ltime				// the time in the local time zone: 01:23:23
	Lmicroseconds			// microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile			// full file name and line number: /a/b/c/d.go:23
	Lshortfile			// final file name element and line number: d.go:23. overrides Llongfile
	LUTC				// if Ldate or Ltime is set, use UTC rather than the local time zone
	Lmsgprefix			// move the "prefix" from the beginning of the line to before the message
	LstdFlags	= Ldate | Ltime	// initial values for the standard logger
)

// A Logger represents an active logging object that generates lines of
//line /usr/local/go/src/log/log.go:52
// output to an io.Writer. Each logging operation makes a single call to
//line /usr/local/go/src/log/log.go:52
// the Writer's Write method. A Logger can be used simultaneously from
//line /usr/local/go/src/log/log.go:52
// multiple goroutines; it guarantees to serialize access to the Writer.
//line /usr/local/go/src/log/log.go:56
type Logger struct {
	mu		sync.Mutex	// ensures atomic writes; protects the following fields
	prefix		string		// prefix on each line to identify the logger (but see Lmsgprefix)
	flag		int		// properties
	out		io.Writer	// destination for output
	buf		[]byte		// for accumulating text to write
	isDiscard	atomic.Bool	// whether out == io.Discard
}

// New creates a new Logger. The out variable sets the
//line /usr/local/go/src/log/log.go:65
// destination to which log data will be written.
//line /usr/local/go/src/log/log.go:65
// The prefix appears at the beginning of each generated log line, or
//line /usr/local/go/src/log/log.go:65
// after the log header if the Lmsgprefix flag is provided.
//line /usr/local/go/src/log/log.go:65
// The flag argument defines the logging properties.
//line /usr/local/go/src/log/log.go:70
func New(out io.Writer, prefix string, flag int) *Logger {
//line /usr/local/go/src/log/log.go:70
	_go_fuzz_dep_.CoverTab[28567]++
					l := &Logger{out: out, prefix: prefix, flag: flag}
					if out == io.Discard {
//line /usr/local/go/src/log/log.go:72
		_go_fuzz_dep_.CoverTab[28569]++
						l.isDiscard.Store(true)
//line /usr/local/go/src/log/log.go:73
		// _ = "end of CoverTab[28569]"
	} else {
//line /usr/local/go/src/log/log.go:74
		_go_fuzz_dep_.CoverTab[28570]++
//line /usr/local/go/src/log/log.go:74
		// _ = "end of CoverTab[28570]"
//line /usr/local/go/src/log/log.go:74
	}
//line /usr/local/go/src/log/log.go:74
	// _ = "end of CoverTab[28567]"
//line /usr/local/go/src/log/log.go:74
	_go_fuzz_dep_.CoverTab[28568]++
					return l
//line /usr/local/go/src/log/log.go:75
	// _ = "end of CoverTab[28568]"
}

// SetOutput sets the output destination for the logger.
func (l *Logger) SetOutput(w io.Writer) {
//line /usr/local/go/src/log/log.go:79
	_go_fuzz_dep_.CoverTab[28571]++
					l.mu.Lock()
					defer l.mu.Unlock()
					l.out = w
					l.isDiscard.Store(w == io.Discard)
//line /usr/local/go/src/log/log.go:83
	// _ = "end of CoverTab[28571]"
}

var std = New(os.Stderr, "", LstdFlags)

// Default returns the standard logger used by the package-level output functions.
func Default() *Logger	{ _go_fuzz_dep_.CoverTab[28572]++; return std; // _ = "end of CoverTab[28572]" }

// Cheap integer to fixed-width decimal ASCII. Give a negative width to avoid zero-padding.
func itoa(buf *[]byte, i int, wid int) {
//line /usr/local/go/src/log/log.go:92
	_go_fuzz_dep_.CoverTab[28573]++
	// Assemble decimal in reverse order.
	var b [20]byte
	bp := len(b) - 1
	for i >= 10 || func() bool {
//line /usr/local/go/src/log/log.go:96
		_go_fuzz_dep_.CoverTab[28575]++
//line /usr/local/go/src/log/log.go:96
		return wid > 1
//line /usr/local/go/src/log/log.go:96
		// _ = "end of CoverTab[28575]"
//line /usr/local/go/src/log/log.go:96
	}() {
//line /usr/local/go/src/log/log.go:96
			_go_fuzz_dep_.CoverTab[28576]++
							wid--
							q := i / 10
							b[bp] = byte('0' + i - q*10)
							bp--
							i = q
//line /usr/local/go/src/log/log.go:101
		// _ = "end of CoverTab[28576]"
	}
//line /usr/local/go/src/log/log.go:102
	// _ = "end of CoverTab[28573]"
//line /usr/local/go/src/log/log.go:102
	_go_fuzz_dep_.CoverTab[28574]++

						b[bp] = byte('0' + i)
						*buf = append(*buf, b[bp:]...)
//line /usr/local/go/src/log/log.go:105
	// _ = "end of CoverTab[28574]"
}

// formatHeader writes log header to buf in following order:
//line /usr/local/go/src/log/log.go:108
//   - l.prefix (if it's not blank and Lmsgprefix is unset),
//line /usr/local/go/src/log/log.go:108
//   - date and/or time (if corresponding flags are provided),
//line /usr/local/go/src/log/log.go:108
//   - file and line number (if corresponding flags are provided),
//line /usr/local/go/src/log/log.go:108
//   - l.prefix (if it's not blank and Lmsgprefix is set).
//line /usr/local/go/src/log/log.go:113
func (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int) {
//line /usr/local/go/src/log/log.go:113
	_go_fuzz_dep_.CoverTab[28577]++
						if l.flag&Lmsgprefix == 0 {
//line /usr/local/go/src/log/log.go:114
		_go_fuzz_dep_.CoverTab[28581]++
							*buf = append(*buf, l.prefix...)
//line /usr/local/go/src/log/log.go:115
		// _ = "end of CoverTab[28581]"
	} else {
//line /usr/local/go/src/log/log.go:116
		_go_fuzz_dep_.CoverTab[28582]++
//line /usr/local/go/src/log/log.go:116
		// _ = "end of CoverTab[28582]"
//line /usr/local/go/src/log/log.go:116
	}
//line /usr/local/go/src/log/log.go:116
	// _ = "end of CoverTab[28577]"
//line /usr/local/go/src/log/log.go:116
	_go_fuzz_dep_.CoverTab[28578]++
						if l.flag&(Ldate|Ltime|Lmicroseconds) != 0 {
//line /usr/local/go/src/log/log.go:117
		_go_fuzz_dep_.CoverTab[28583]++
							if l.flag&LUTC != 0 {
//line /usr/local/go/src/log/log.go:118
			_go_fuzz_dep_.CoverTab[28586]++
								t = t.UTC()
//line /usr/local/go/src/log/log.go:119
			// _ = "end of CoverTab[28586]"
		} else {
//line /usr/local/go/src/log/log.go:120
			_go_fuzz_dep_.CoverTab[28587]++
//line /usr/local/go/src/log/log.go:120
			// _ = "end of CoverTab[28587]"
//line /usr/local/go/src/log/log.go:120
		}
//line /usr/local/go/src/log/log.go:120
		// _ = "end of CoverTab[28583]"
//line /usr/local/go/src/log/log.go:120
		_go_fuzz_dep_.CoverTab[28584]++
							if l.flag&Ldate != 0 {
//line /usr/local/go/src/log/log.go:121
			_go_fuzz_dep_.CoverTab[28588]++
								year, month, day := t.Date()
								itoa(buf, year, 4)
								*buf = append(*buf, '/')
								itoa(buf, int(month), 2)
								*buf = append(*buf, '/')
								itoa(buf, day, 2)
								*buf = append(*buf, ' ')
//line /usr/local/go/src/log/log.go:128
			// _ = "end of CoverTab[28588]"
		} else {
//line /usr/local/go/src/log/log.go:129
			_go_fuzz_dep_.CoverTab[28589]++
//line /usr/local/go/src/log/log.go:129
			// _ = "end of CoverTab[28589]"
//line /usr/local/go/src/log/log.go:129
		}
//line /usr/local/go/src/log/log.go:129
		// _ = "end of CoverTab[28584]"
//line /usr/local/go/src/log/log.go:129
		_go_fuzz_dep_.CoverTab[28585]++
							if l.flag&(Ltime|Lmicroseconds) != 0 {
//line /usr/local/go/src/log/log.go:130
			_go_fuzz_dep_.CoverTab[28590]++
								hour, min, sec := t.Clock()
								itoa(buf, hour, 2)
								*buf = append(*buf, ':')
								itoa(buf, min, 2)
								*buf = append(*buf, ':')
								itoa(buf, sec, 2)
								if l.flag&Lmicroseconds != 0 {
//line /usr/local/go/src/log/log.go:137
				_go_fuzz_dep_.CoverTab[28592]++
									*buf = append(*buf, '.')
									itoa(buf, t.Nanosecond()/1e3, 6)
//line /usr/local/go/src/log/log.go:139
				// _ = "end of CoverTab[28592]"
			} else {
//line /usr/local/go/src/log/log.go:140
				_go_fuzz_dep_.CoverTab[28593]++
//line /usr/local/go/src/log/log.go:140
				// _ = "end of CoverTab[28593]"
//line /usr/local/go/src/log/log.go:140
			}
//line /usr/local/go/src/log/log.go:140
			// _ = "end of CoverTab[28590]"
//line /usr/local/go/src/log/log.go:140
			_go_fuzz_dep_.CoverTab[28591]++
								*buf = append(*buf, ' ')
//line /usr/local/go/src/log/log.go:141
			// _ = "end of CoverTab[28591]"
		} else {
//line /usr/local/go/src/log/log.go:142
			_go_fuzz_dep_.CoverTab[28594]++
//line /usr/local/go/src/log/log.go:142
			// _ = "end of CoverTab[28594]"
//line /usr/local/go/src/log/log.go:142
		}
//line /usr/local/go/src/log/log.go:142
		// _ = "end of CoverTab[28585]"
	} else {
//line /usr/local/go/src/log/log.go:143
		_go_fuzz_dep_.CoverTab[28595]++
//line /usr/local/go/src/log/log.go:143
		// _ = "end of CoverTab[28595]"
//line /usr/local/go/src/log/log.go:143
	}
//line /usr/local/go/src/log/log.go:143
	// _ = "end of CoverTab[28578]"
//line /usr/local/go/src/log/log.go:143
	_go_fuzz_dep_.CoverTab[28579]++
						if l.flag&(Lshortfile|Llongfile) != 0 {
//line /usr/local/go/src/log/log.go:144
		_go_fuzz_dep_.CoverTab[28596]++
							if l.flag&Lshortfile != 0 {
//line /usr/local/go/src/log/log.go:145
			_go_fuzz_dep_.CoverTab[28598]++
								short := file
								for i := len(file) - 1; i > 0; i-- {
//line /usr/local/go/src/log/log.go:147
				_go_fuzz_dep_.CoverTab[28600]++
									if file[i] == '/' {
//line /usr/local/go/src/log/log.go:148
					_go_fuzz_dep_.CoverTab[28601]++
										short = file[i+1:]
										break
//line /usr/local/go/src/log/log.go:150
					// _ = "end of CoverTab[28601]"
				} else {
//line /usr/local/go/src/log/log.go:151
					_go_fuzz_dep_.CoverTab[28602]++
//line /usr/local/go/src/log/log.go:151
					// _ = "end of CoverTab[28602]"
//line /usr/local/go/src/log/log.go:151
				}
//line /usr/local/go/src/log/log.go:151
				// _ = "end of CoverTab[28600]"
			}
//line /usr/local/go/src/log/log.go:152
			// _ = "end of CoverTab[28598]"
//line /usr/local/go/src/log/log.go:152
			_go_fuzz_dep_.CoverTab[28599]++
								file = short
//line /usr/local/go/src/log/log.go:153
			// _ = "end of CoverTab[28599]"
		} else {
//line /usr/local/go/src/log/log.go:154
			_go_fuzz_dep_.CoverTab[28603]++
//line /usr/local/go/src/log/log.go:154
			// _ = "end of CoverTab[28603]"
//line /usr/local/go/src/log/log.go:154
		}
//line /usr/local/go/src/log/log.go:154
		// _ = "end of CoverTab[28596]"
//line /usr/local/go/src/log/log.go:154
		_go_fuzz_dep_.CoverTab[28597]++
							*buf = append(*buf, file...)
							*buf = append(*buf, ':')
							itoa(buf, line, -1)
							*buf = append(*buf, ": "...)
//line /usr/local/go/src/log/log.go:158
		// _ = "end of CoverTab[28597]"
	} else {
//line /usr/local/go/src/log/log.go:159
		_go_fuzz_dep_.CoverTab[28604]++
//line /usr/local/go/src/log/log.go:159
		// _ = "end of CoverTab[28604]"
//line /usr/local/go/src/log/log.go:159
	}
//line /usr/local/go/src/log/log.go:159
	// _ = "end of CoverTab[28579]"
//line /usr/local/go/src/log/log.go:159
	_go_fuzz_dep_.CoverTab[28580]++
						if l.flag&Lmsgprefix != 0 {
//line /usr/local/go/src/log/log.go:160
		_go_fuzz_dep_.CoverTab[28605]++
							*buf = append(*buf, l.prefix...)
//line /usr/local/go/src/log/log.go:161
		// _ = "end of CoverTab[28605]"
	} else {
//line /usr/local/go/src/log/log.go:162
		_go_fuzz_dep_.CoverTab[28606]++
//line /usr/local/go/src/log/log.go:162
		// _ = "end of CoverTab[28606]"
//line /usr/local/go/src/log/log.go:162
	}
//line /usr/local/go/src/log/log.go:162
	// _ = "end of CoverTab[28580]"
}

// Output writes the output for a logging event. The string s contains
//line /usr/local/go/src/log/log.go:165
// the text to print after the prefix specified by the flags of the
//line /usr/local/go/src/log/log.go:165
// Logger. A newline is appended if the last character of s is not
//line /usr/local/go/src/log/log.go:165
// already a newline. Calldepth is used to recover the PC and is
//line /usr/local/go/src/log/log.go:165
// provided for generality, although at the moment on all pre-defined
//line /usr/local/go/src/log/log.go:165
// paths it will be 2.
//line /usr/local/go/src/log/log.go:171
func (l *Logger) Output(calldepth int, s string) error {
//line /usr/local/go/src/log/log.go:171
	_go_fuzz_dep_.CoverTab[28607]++
						now := time.Now()
						var file string
						var line int
						l.mu.Lock()
						defer l.mu.Unlock()
						if l.flag&(Lshortfile|Llongfile) != 0 {
//line /usr/local/go/src/log/log.go:177
		_go_fuzz_dep_.CoverTab[28610]++

							l.mu.Unlock()
							var ok bool
							_, file, line, ok = runtime.Caller(calldepth)
							if !ok {
//line /usr/local/go/src/log/log.go:182
			_go_fuzz_dep_.CoverTab[28612]++
								file = "???"
								line = 0
//line /usr/local/go/src/log/log.go:184
			// _ = "end of CoverTab[28612]"
		} else {
//line /usr/local/go/src/log/log.go:185
			_go_fuzz_dep_.CoverTab[28613]++
//line /usr/local/go/src/log/log.go:185
			// _ = "end of CoverTab[28613]"
//line /usr/local/go/src/log/log.go:185
		}
//line /usr/local/go/src/log/log.go:185
		// _ = "end of CoverTab[28610]"
//line /usr/local/go/src/log/log.go:185
		_go_fuzz_dep_.CoverTab[28611]++
							l.mu.Lock()
//line /usr/local/go/src/log/log.go:186
		// _ = "end of CoverTab[28611]"
	} else {
//line /usr/local/go/src/log/log.go:187
		_go_fuzz_dep_.CoverTab[28614]++
//line /usr/local/go/src/log/log.go:187
		// _ = "end of CoverTab[28614]"
//line /usr/local/go/src/log/log.go:187
	}
//line /usr/local/go/src/log/log.go:187
	// _ = "end of CoverTab[28607]"
//line /usr/local/go/src/log/log.go:187
	_go_fuzz_dep_.CoverTab[28608]++
						l.buf = l.buf[:0]
						l.formatHeader(&l.buf, now, file, line)
						l.buf = append(l.buf, s...)
						if len(s) == 0 || func() bool {
//line /usr/local/go/src/log/log.go:191
		_go_fuzz_dep_.CoverTab[28615]++
//line /usr/local/go/src/log/log.go:191
		return s[len(s)-1] != '\n'
//line /usr/local/go/src/log/log.go:191
		// _ = "end of CoverTab[28615]"
//line /usr/local/go/src/log/log.go:191
	}() {
//line /usr/local/go/src/log/log.go:191
		_go_fuzz_dep_.CoverTab[28616]++
							l.buf = append(l.buf, '\n')
//line /usr/local/go/src/log/log.go:192
		// _ = "end of CoverTab[28616]"
	} else {
//line /usr/local/go/src/log/log.go:193
		_go_fuzz_dep_.CoverTab[28617]++
//line /usr/local/go/src/log/log.go:193
		// _ = "end of CoverTab[28617]"
//line /usr/local/go/src/log/log.go:193
	}
//line /usr/local/go/src/log/log.go:193
	// _ = "end of CoverTab[28608]"
//line /usr/local/go/src/log/log.go:193
	_go_fuzz_dep_.CoverTab[28609]++
						_, err := l.out.Write(l.buf)
						return err
//line /usr/local/go/src/log/log.go:195
	// _ = "end of CoverTab[28609]"
}

// Printf calls l.Output to print to the logger.
//line /usr/local/go/src/log/log.go:198
// Arguments are handled in the manner of fmt.Printf.
//line /usr/local/go/src/log/log.go:200
func (l *Logger) Printf(format string, v ...any) {
//line /usr/local/go/src/log/log.go:200
	_go_fuzz_dep_.CoverTab[28618]++
						if l.isDiscard.Load() {
//line /usr/local/go/src/log/log.go:201
		_go_fuzz_dep_.CoverTab[28620]++
							return
//line /usr/local/go/src/log/log.go:202
		// _ = "end of CoverTab[28620]"
	} else {
//line /usr/local/go/src/log/log.go:203
		_go_fuzz_dep_.CoverTab[28621]++
//line /usr/local/go/src/log/log.go:203
		// _ = "end of CoverTab[28621]"
//line /usr/local/go/src/log/log.go:203
	}
//line /usr/local/go/src/log/log.go:203
	// _ = "end of CoverTab[28618]"
//line /usr/local/go/src/log/log.go:203
	_go_fuzz_dep_.CoverTab[28619]++
						l.Output(2, fmt.Sprintf(format, v...))
//line /usr/local/go/src/log/log.go:204
	// _ = "end of CoverTab[28619]"
}

// Print calls l.Output to print to the logger.
//line /usr/local/go/src/log/log.go:207
// Arguments are handled in the manner of fmt.Print.
//line /usr/local/go/src/log/log.go:209
func (l *Logger) Print(v ...any) {
//line /usr/local/go/src/log/log.go:209
	_go_fuzz_dep_.CoverTab[28622]++
						if l.isDiscard.Load() {
//line /usr/local/go/src/log/log.go:210
		_go_fuzz_dep_.CoverTab[28624]++
							return
//line /usr/local/go/src/log/log.go:211
		// _ = "end of CoverTab[28624]"
	} else {
//line /usr/local/go/src/log/log.go:212
		_go_fuzz_dep_.CoverTab[28625]++
//line /usr/local/go/src/log/log.go:212
		// _ = "end of CoverTab[28625]"
//line /usr/local/go/src/log/log.go:212
	}
//line /usr/local/go/src/log/log.go:212
	// _ = "end of CoverTab[28622]"
//line /usr/local/go/src/log/log.go:212
	_go_fuzz_dep_.CoverTab[28623]++
						l.Output(2, fmt.Sprint(v...))
//line /usr/local/go/src/log/log.go:213
	// _ = "end of CoverTab[28623]"
}

// Println calls l.Output to print to the logger.
//line /usr/local/go/src/log/log.go:216
// Arguments are handled in the manner of fmt.Println.
//line /usr/local/go/src/log/log.go:218
func (l *Logger) Println(v ...any) {
//line /usr/local/go/src/log/log.go:218
	_go_fuzz_dep_.CoverTab[28626]++
						if l.isDiscard.Load() {
//line /usr/local/go/src/log/log.go:219
		_go_fuzz_dep_.CoverTab[28628]++
							return
//line /usr/local/go/src/log/log.go:220
		// _ = "end of CoverTab[28628]"
	} else {
//line /usr/local/go/src/log/log.go:221
		_go_fuzz_dep_.CoverTab[28629]++
//line /usr/local/go/src/log/log.go:221
		// _ = "end of CoverTab[28629]"
//line /usr/local/go/src/log/log.go:221
	}
//line /usr/local/go/src/log/log.go:221
	// _ = "end of CoverTab[28626]"
//line /usr/local/go/src/log/log.go:221
	_go_fuzz_dep_.CoverTab[28627]++
						l.Output(2, fmt.Sprintln(v...))
//line /usr/local/go/src/log/log.go:222
	// _ = "end of CoverTab[28627]"
}

// Fatal is equivalent to l.Print() followed by a call to os.Exit(1).
func (l *Logger) Fatal(v ...any) {
//line /usr/local/go/src/log/log.go:226
	_go_fuzz_dep_.CoverTab[28630]++
						l.Output(2, fmt.Sprint(v...))
						os.Exit(1)
//line /usr/local/go/src/log/log.go:228
	// _ = "end of CoverTab[28630]"
}

// Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).
func (l *Logger) Fatalf(format string, v ...any) {
//line /usr/local/go/src/log/log.go:232
	_go_fuzz_dep_.CoverTab[28631]++
						l.Output(2, fmt.Sprintf(format, v...))
						os.Exit(1)
//line /usr/local/go/src/log/log.go:234
	// _ = "end of CoverTab[28631]"
}

// Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).
func (l *Logger) Fatalln(v ...any) {
//line /usr/local/go/src/log/log.go:238
	_go_fuzz_dep_.CoverTab[28632]++
						l.Output(2, fmt.Sprintln(v...))
						os.Exit(1)
//line /usr/local/go/src/log/log.go:240
	// _ = "end of CoverTab[28632]"
}

// Panic is equivalent to l.Print() followed by a call to panic().
func (l *Logger) Panic(v ...any) {
//line /usr/local/go/src/log/log.go:244
	_go_fuzz_dep_.CoverTab[28633]++
						s := fmt.Sprint(v...)
						l.Output(2, s)
						panic(s)
//line /usr/local/go/src/log/log.go:247
	// _ = "end of CoverTab[28633]"
}

// Panicf is equivalent to l.Printf() followed by a call to panic().
func (l *Logger) Panicf(format string, v ...any) {
//line /usr/local/go/src/log/log.go:251
	_go_fuzz_dep_.CoverTab[28634]++
						s := fmt.Sprintf(format, v...)
						l.Output(2, s)
						panic(s)
//line /usr/local/go/src/log/log.go:254
	// _ = "end of CoverTab[28634]"
}

// Panicln is equivalent to l.Println() followed by a call to panic().
func (l *Logger) Panicln(v ...any) {
//line /usr/local/go/src/log/log.go:258
	_go_fuzz_dep_.CoverTab[28635]++
						s := fmt.Sprintln(v...)
						l.Output(2, s)
						panic(s)
//line /usr/local/go/src/log/log.go:261
	// _ = "end of CoverTab[28635]"
}

// Flags returns the output flags for the logger.
//line /usr/local/go/src/log/log.go:264
// The flag bits are Ldate, Ltime, and so on.
//line /usr/local/go/src/log/log.go:266
func (l *Logger) Flags() int {
//line /usr/local/go/src/log/log.go:266
	_go_fuzz_dep_.CoverTab[28636]++
						l.mu.Lock()
						defer l.mu.Unlock()
						return l.flag
//line /usr/local/go/src/log/log.go:269
	// _ = "end of CoverTab[28636]"
}

// SetFlags sets the output flags for the logger.
//line /usr/local/go/src/log/log.go:272
// The flag bits are Ldate, Ltime, and so on.
//line /usr/local/go/src/log/log.go:274
func (l *Logger) SetFlags(flag int) {
//line /usr/local/go/src/log/log.go:274
	_go_fuzz_dep_.CoverTab[28637]++
						l.mu.Lock()
						defer l.mu.Unlock()
						l.flag = flag
//line /usr/local/go/src/log/log.go:277
	// _ = "end of CoverTab[28637]"
}

// Prefix returns the output prefix for the logger.
func (l *Logger) Prefix() string {
//line /usr/local/go/src/log/log.go:281
	_go_fuzz_dep_.CoverTab[28638]++
						l.mu.Lock()
						defer l.mu.Unlock()
						return l.prefix
//line /usr/local/go/src/log/log.go:284
	// _ = "end of CoverTab[28638]"
}

// SetPrefix sets the output prefix for the logger.
func (l *Logger) SetPrefix(prefix string) {
//line /usr/local/go/src/log/log.go:288
	_go_fuzz_dep_.CoverTab[28639]++
						l.mu.Lock()
						defer l.mu.Unlock()
						l.prefix = prefix
//line /usr/local/go/src/log/log.go:291
	// _ = "end of CoverTab[28639]"
}

// Writer returns the output destination for the logger.
func (l *Logger) Writer() io.Writer {
//line /usr/local/go/src/log/log.go:295
	_go_fuzz_dep_.CoverTab[28640]++
						l.mu.Lock()
						defer l.mu.Unlock()
						return l.out
//line /usr/local/go/src/log/log.go:298
	// _ = "end of CoverTab[28640]"
}

// SetOutput sets the output destination for the standard logger.
func SetOutput(w io.Writer) {
//line /usr/local/go/src/log/log.go:302
	_go_fuzz_dep_.CoverTab[28641]++
						std.SetOutput(w)
//line /usr/local/go/src/log/log.go:303
	// _ = "end of CoverTab[28641]"
}

// Flags returns the output flags for the standard logger.
//line /usr/local/go/src/log/log.go:306
// The flag bits are Ldate, Ltime, and so on.
//line /usr/local/go/src/log/log.go:308
func Flags() int {
//line /usr/local/go/src/log/log.go:308
	_go_fuzz_dep_.CoverTab[28642]++
						return std.Flags()
//line /usr/local/go/src/log/log.go:309
	// _ = "end of CoverTab[28642]"
}

// SetFlags sets the output flags for the standard logger.
//line /usr/local/go/src/log/log.go:312
// The flag bits are Ldate, Ltime, and so on.
//line /usr/local/go/src/log/log.go:314
func SetFlags(flag int) {
//line /usr/local/go/src/log/log.go:314
	_go_fuzz_dep_.CoverTab[28643]++
						std.SetFlags(flag)
//line /usr/local/go/src/log/log.go:315
	// _ = "end of CoverTab[28643]"
}

// Prefix returns the output prefix for the standard logger.
func Prefix() string {
//line /usr/local/go/src/log/log.go:319
	_go_fuzz_dep_.CoverTab[28644]++
						return std.Prefix()
//line /usr/local/go/src/log/log.go:320
	// _ = "end of CoverTab[28644]"
}

// SetPrefix sets the output prefix for the standard logger.
func SetPrefix(prefix string) {
//line /usr/local/go/src/log/log.go:324
	_go_fuzz_dep_.CoverTab[28645]++
						std.SetPrefix(prefix)
//line /usr/local/go/src/log/log.go:325
	// _ = "end of CoverTab[28645]"
}

// Writer returns the output destination for the standard logger.
func Writer() io.Writer {
//line /usr/local/go/src/log/log.go:329
	_go_fuzz_dep_.CoverTab[28646]++
						return std.Writer()
//line /usr/local/go/src/log/log.go:330
	// _ = "end of CoverTab[28646]"
}

//line /usr/local/go/src/log/log.go:335
// Print calls Output to print to the standard logger.
//line /usr/local/go/src/log/log.go:335
// Arguments are handled in the manner of fmt.Print.
//line /usr/local/go/src/log/log.go:337
func Print(v ...any) {
//line /usr/local/go/src/log/log.go:337
	_go_fuzz_dep_.CoverTab[28647]++
						if std.isDiscard.Load() {
//line /usr/local/go/src/log/log.go:338
		_go_fuzz_dep_.CoverTab[28649]++
							return
//line /usr/local/go/src/log/log.go:339
		// _ = "end of CoverTab[28649]"
	} else {
//line /usr/local/go/src/log/log.go:340
		_go_fuzz_dep_.CoverTab[28650]++
//line /usr/local/go/src/log/log.go:340
		// _ = "end of CoverTab[28650]"
//line /usr/local/go/src/log/log.go:340
	}
//line /usr/local/go/src/log/log.go:340
	// _ = "end of CoverTab[28647]"
//line /usr/local/go/src/log/log.go:340
	_go_fuzz_dep_.CoverTab[28648]++
						std.Output(2, fmt.Sprint(v...))
//line /usr/local/go/src/log/log.go:341
	// _ = "end of CoverTab[28648]"
}

// Printf calls Output to print to the standard logger.
//line /usr/local/go/src/log/log.go:344
// Arguments are handled in the manner of fmt.Printf.
//line /usr/local/go/src/log/log.go:346
func Printf(format string, v ...any) {
//line /usr/local/go/src/log/log.go:346
	_go_fuzz_dep_.CoverTab[28651]++
						if std.isDiscard.Load() {
//line /usr/local/go/src/log/log.go:347
		_go_fuzz_dep_.CoverTab[28653]++
							return
//line /usr/local/go/src/log/log.go:348
		// _ = "end of CoverTab[28653]"
	} else {
//line /usr/local/go/src/log/log.go:349
		_go_fuzz_dep_.CoverTab[28654]++
//line /usr/local/go/src/log/log.go:349
		// _ = "end of CoverTab[28654]"
//line /usr/local/go/src/log/log.go:349
	}
//line /usr/local/go/src/log/log.go:349
	// _ = "end of CoverTab[28651]"
//line /usr/local/go/src/log/log.go:349
	_go_fuzz_dep_.CoverTab[28652]++
						std.Output(2, fmt.Sprintf(format, v...))
//line /usr/local/go/src/log/log.go:350
	// _ = "end of CoverTab[28652]"
}

// Println calls Output to print to the standard logger.
//line /usr/local/go/src/log/log.go:353
// Arguments are handled in the manner of fmt.Println.
//line /usr/local/go/src/log/log.go:355
func Println(v ...any) {
//line /usr/local/go/src/log/log.go:355
	_go_fuzz_dep_.CoverTab[28655]++
						if std.isDiscard.Load() {
//line /usr/local/go/src/log/log.go:356
		_go_fuzz_dep_.CoverTab[28657]++
							return
//line /usr/local/go/src/log/log.go:357
		// _ = "end of CoverTab[28657]"
	} else {
//line /usr/local/go/src/log/log.go:358
		_go_fuzz_dep_.CoverTab[28658]++
//line /usr/local/go/src/log/log.go:358
		// _ = "end of CoverTab[28658]"
//line /usr/local/go/src/log/log.go:358
	}
//line /usr/local/go/src/log/log.go:358
	// _ = "end of CoverTab[28655]"
//line /usr/local/go/src/log/log.go:358
	_go_fuzz_dep_.CoverTab[28656]++
						std.Output(2, fmt.Sprintln(v...))
//line /usr/local/go/src/log/log.go:359
	// _ = "end of CoverTab[28656]"
}

// Fatal is equivalent to Print() followed by a call to os.Exit(1).
func Fatal(v ...any) {
//line /usr/local/go/src/log/log.go:363
	_go_fuzz_dep_.CoverTab[28659]++
						std.Output(2, fmt.Sprint(v...))
						os.Exit(1)
//line /usr/local/go/src/log/log.go:365
	// _ = "end of CoverTab[28659]"
}

// Fatalf is equivalent to Printf() followed by a call to os.Exit(1).
func Fatalf(format string, v ...any) {
//line /usr/local/go/src/log/log.go:369
	_go_fuzz_dep_.CoverTab[28660]++
						std.Output(2, fmt.Sprintf(format, v...))
						os.Exit(1)
//line /usr/local/go/src/log/log.go:371
	// _ = "end of CoverTab[28660]"
}

// Fatalln is equivalent to Println() followed by a call to os.Exit(1).
func Fatalln(v ...any) {
//line /usr/local/go/src/log/log.go:375
	_go_fuzz_dep_.CoverTab[28661]++
						std.Output(2, fmt.Sprintln(v...))
						os.Exit(1)
//line /usr/local/go/src/log/log.go:377
	// _ = "end of CoverTab[28661]"
}

// Panic is equivalent to Print() followed by a call to panic().
func Panic(v ...any) {
//line /usr/local/go/src/log/log.go:381
	_go_fuzz_dep_.CoverTab[28662]++
						s := fmt.Sprint(v...)
						std.Output(2, s)
						panic(s)
//line /usr/local/go/src/log/log.go:384
	// _ = "end of CoverTab[28662]"
}

// Panicf is equivalent to Printf() followed by a call to panic().
func Panicf(format string, v ...any) {
//line /usr/local/go/src/log/log.go:388
	_go_fuzz_dep_.CoverTab[28663]++
						s := fmt.Sprintf(format, v...)
						std.Output(2, s)
						panic(s)
//line /usr/local/go/src/log/log.go:391
	// _ = "end of CoverTab[28663]"
}

// Panicln is equivalent to Println() followed by a call to panic().
func Panicln(v ...any) {
//line /usr/local/go/src/log/log.go:395
	_go_fuzz_dep_.CoverTab[28664]++
						s := fmt.Sprintln(v...)
						std.Output(2, s)
						panic(s)
//line /usr/local/go/src/log/log.go:398
	// _ = "end of CoverTab[28664]"
}

// Output writes the output for a logging event. The string s contains
//line /usr/local/go/src/log/log.go:401
// the text to print after the prefix specified by the flags of the
//line /usr/local/go/src/log/log.go:401
// Logger. A newline is appended if the last character of s is not
//line /usr/local/go/src/log/log.go:401
// already a newline. Calldepth is the count of the number of
//line /usr/local/go/src/log/log.go:401
// frames to skip when computing the file name and line number
//line /usr/local/go/src/log/log.go:401
// if Llongfile or Lshortfile is set; a value of 1 will print the details
//line /usr/local/go/src/log/log.go:401
// for the caller of Output.
//line /usr/local/go/src/log/log.go:408
func Output(calldepth int, s string) error {
//line /usr/local/go/src/log/log.go:408
	_go_fuzz_dep_.CoverTab[28665]++
						return std.Output(calldepth+1, s)
//line /usr/local/go/src/log/log.go:409
	// _ = "end of CoverTab[28665]"
}

//line /usr/local/go/src/log/log.go:410
var _ = _atomic_.LoadUint32(&_go_fuzz_dep_.NoUse)
//line /usr/local/go/src/log/log.go:410
var _ = _go_fuzz_dep_.CoverTab
