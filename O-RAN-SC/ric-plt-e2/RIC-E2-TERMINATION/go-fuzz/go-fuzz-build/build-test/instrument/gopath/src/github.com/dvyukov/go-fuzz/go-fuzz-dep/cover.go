// Copyright 2019 go-fuzz project authors. All rights reserved.
// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

//go:build gofuzz
// +build gofuzz

package gofuzzdep

import (
	"sync"
	"time"

	. "github.com/dvyukov/go-fuzz/go-fuzz-defs"
)

// Bool is just a bool.
// It is used by code autogenerated by go-fuzz-build
// to avoid compilation errors when a user's code shadows the built-in bool.
type Bool = bool

// CoverTab holds code coverage.
// It is initialized to a new array so that instrumentation
// executed during process initialization has somewhere to write to.
// It is replaced by a newly initialized array when it is
// time for actual instrumentation to commence.
var CoverTab = new([CoverSize]byte)
var EndCoverTab = new([CoverSize]byte)

var RoutineInfo = NewGoroutineInfo()
var RoutineNum = uint32(0)

var FirstRun = true

var oldCreated map[uint32]bool

var outFD FD
var inFD FD
var mem []byte
var startTime time.Time

// only used to make sure no atomic import is unused by calling atomic.LoadUint32(&NoUse)
var NoUse = uint32(0)

var LoopMutex sync.Mutex

type GoroutineInfo struct {
	createdRoutineNums    map[uint32]bool
	terminatedRoutineNums map[uint32]bool
	mu                    sync.Mutex
}

func NewGoroutineInfo() *GoroutineInfo {
	return &GoroutineInfo{
		createdRoutineNums:    make(map[uint32]bool),
		terminatedRoutineNums: make(map[uint32]bool),
		mu:                    sync.Mutex{},
	}
}

func (gi *GoroutineInfo) AddCreatedRoutineNum(routineNum uint32) {
	gi.mu.Lock()
	defer gi.mu.Unlock()
	gi.createdRoutineNums[routineNum] = true
}

func (gi *GoroutineInfo) AddTerminatedRoutineNum(routineNum uint32) {
	gi.mu.Lock()
	defer gi.mu.Unlock()
	gi.terminatedRoutineNums[routineNum] = true
}

func (gi *GoroutineInfo) GetCreatedRoutineNums() map[uint32]bool {
	gi.mu.Lock()
	defer gi.mu.Unlock()
	return copyUintMap(gi.createdRoutineNums)
}

func copyUintMap(in map[uint32]bool) map[uint32]bool {
	newMap := make(map[uint32]bool)
	for k, v := range in {
		newMap[k] = v
	}
	return newMap
}

func (gi *GoroutineInfo) WaitTillAllNewlyCreatedTerminates(old map[uint32]bool, timeout time.Duration) {
	// fmt.Printf("old: %v\n", old)
	startTime := time.Now()
	for {
		allTerminated := true
		gi.mu.Lock()
		if time.Since(startTime) > timeout {
			gi.mu.Unlock()
			return
		}

		// fmt.Printf("created: %v, terminated: %v\n", gi.createdRoutineNums, gi.terminatedRoutineNums)
		for routineNum := range gi.createdRoutineNums {
			if _, ok := old[routineNum]; !ok {
				if _, ok := gi.terminatedRoutineNums[routineNum]; !ok {
					allTerminated = false
					continue
				}
			}
		}
		gi.mu.Unlock()
		if allTerminated {
			return
		}
		// time.Sleep(1 * time.Second)
	}
}
